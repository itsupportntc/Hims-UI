{"ast":null,"code":"import { Encoding, Save } from '@syncfusion/ej2-file-utils';\n/* eslint-disable */\n\nvar Utils =\n/** @__PURE__ @class */\nfunction () {\n  function Utils() {}\n\n  Utils.bitReverse = function (value) {\n    return Utils.reverseBits[value & 15] << 12 | Utils.reverseBits[value >> 4 & 15] << 8 | Utils.reverseBits[value >> 8 & 15] << 4 | Utils.reverseBits[value >> 12];\n  };\n\n  Utils.bitConverterToInt32 = function (value, index) {\n    return value[index] | value[index + 1] << 8 | value[index + 2] << 16 | value[index + 3] << 24;\n  };\n\n  Utils.bitConverterToInt16 = function (value, index) {\n    return value[index] | value[index + 1] << 8;\n  };\n\n  Utils.bitConverterToUInt32 = function (value) {\n    var uint = new Uint32Array(1);\n    uint[0] = value;\n    return uint[0];\n  };\n\n  Utils.bitConverterToUInt16 = function (value, index) {\n    var uint = new Uint16Array(1);\n    uint[0] = value[index] | value[index + 1] << 8;\n    return uint[0];\n  };\n\n  Utils.bitConverterUintToInt32 = function (value) {\n    var uint = new Int32Array(1);\n    uint[0] = value;\n    return uint[0];\n  };\n\n  Utils.bitConverterInt32ToUint = function (value) {\n    var uint = new Uint32Array(1);\n    uint[0] = value;\n    return uint[0];\n  };\n\n  Utils.bitConverterInt32ToInt16 = function (value) {\n    var uint = new Int16Array(1);\n    uint[0] = value;\n    return uint[0];\n  };\n\n  Utils.byteToString = function (value) {\n    var str = '';\n\n    for (var i = 0; i < value.length; i++) {\n      str += String.fromCharCode(value[i]);\n    }\n\n    return str;\n  };\n\n  Utils.byteIntToString = function (value) {\n    var str = '';\n\n    for (var i = 0; i < value.length; i++) {\n      str += String.fromCharCode(value[i]);\n    }\n\n    return str;\n  };\n\n  Utils.arrayCopy = function (source, sourceIndex, destination, destinationIndex, dataToCopy) {\n    var temp = new Uint8Array(source.buffer, sourceIndex);\n    var data = temp.subarray(0, dataToCopy);\n    destination.set(data, destinationIndex);\n  };\n\n  Utils.mergeArray = function (arrayOne, arrayTwo) {\n    var mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n    mergedArray.set(arrayOne);\n    mergedArray.set(arrayTwo, arrayOne.length);\n    return mergedArray;\n  };\n  /**\n   * @private\n   */\n\n\n  Utils.encodedString = function (input) {\n    var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var chr1;\n    var chr2;\n    var chr3;\n    var encode1;\n    var encode2;\n    var encode3;\n    var encode4;\n    var count = 0;\n    var resultIndex = 0;\n    /*let dataUrlPrefix: string = 'data:';*/\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n    var totalLength = input.length * 3 / 4;\n\n    if (input.charAt(input.length - 1) === keyStr.charAt(64)) {\n      totalLength--;\n    }\n\n    if (input.charAt(input.length - 2) === keyStr.charAt(64)) {\n      totalLength--;\n    }\n\n    if (totalLength % 1 !== 0) {\n      // totalLength is not an integer, the length does not match a valid\n      // base64 content. That can happen if:\n      // - the input is not a base64 content\n      // - the input is *almost* a base64 content, with a extra chars at the\n      // beginning or at the end\n      // - the input uses a base64 variant (base64url for example)\n      throw new Error('Invalid base64 input, bad content length.');\n    }\n\n    var output = new Uint8Array(totalLength | 0);\n\n    while (count < input.length) {\n      encode1 = keyStr.indexOf(input.charAt(count++));\n      encode2 = keyStr.indexOf(input.charAt(count++));\n      encode3 = keyStr.indexOf(input.charAt(count++));\n      encode4 = keyStr.indexOf(input.charAt(count++));\n      chr1 = encode1 << 2 | encode2 >> 4;\n      chr2 = (encode2 & 15) << 4 | encode3 >> 2;\n      chr3 = (encode3 & 3) << 6 | encode4;\n      output[resultIndex++] = chr1;\n\n      if (encode3 !== 64) {\n        output[resultIndex++] = chr2;\n      }\n\n      if (encode4 !== 64) {\n        output[resultIndex++] = chr3;\n      }\n    }\n\n    return output;\n  };\n\n  Utils.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n  Utils.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  return Utils;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n\n\nvar CRC32TABLE = []; /// <summary>\n/// Size of the int value in bytes.\n/// </summary>\n\nvar INT_SIZE = 4; /// <summary>\n/// Size of the short value in bytes.\n/// </summary>\n\nvar SHORT_SIZE = 2; /// <summary>\n/// End of central directory signature.\n/// </summary>\n\nvar CentralDirectoryEndSignature = 0x06054b50; /// <summary>\n/// Offset to the size field in the End of central directory record.\n/// </summary>\n\nvar CentralDirSizeOffset = 12; /// <summary>\n/// Central header signature.\n/// </summary>\n\nvar CentralHeaderSignature = 0x02014b50; /// <summary>\n/// Buffer size.\n/// </summary>\n\nvar BufferSize = 4096;\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\n\nvar ZipArchive =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * constructor for creating ZipArchive instance\n   */\n  function ZipArchive() {\n    if (CRC32TABLE.length === 0) {\n      ZipArchive.initCrc32Table();\n    }\n\n    this.files = [];\n    this.level = 'Normal';\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n\n  Object.defineProperty(ZipArchive.prototype, \"items\", {\n    get: function () {\n      return this.files;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n    /**\n     * gets compression level\n     */\n    get: function () {\n      return this.level;\n    },\n\n    /**\n     * sets compression level\n     */\n    set: function (level) {\n      this.level = level;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchive.prototype, \"length\", {\n    /**\n     * gets items count\n     */\n    get: function () {\n      if (this.files === undefined) {\n        return 0;\n      }\n\n      return this.files.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * add new item to archive\n   * @param {ZipArchiveItem} item - item to be added\n   * @returns {void}\n   */\n\n  ZipArchive.prototype.addItem = function (item) {\n    if (item === null || item === undefined) {\n      throw new Error('ArgumentException: item cannot be null or undefined');\n    }\n\n    for (var i = 0; i < this.files.length; i++) {\n      var file = this.files[i];\n\n      if (file instanceof ZipArchiveItem) {\n        if (file.name === item.name) {\n          throw new Error('item with same name already exist');\n        }\n      }\n    }\n\n    this.files.push(item);\n  };\n  /**\n   * add new directory to archive\n   * @param directoryName directoryName to be created\n   * @returns {void}\n   */\n\n\n  ZipArchive.prototype.addDirectory = function (directoryName) {\n    if (directoryName === null || directoryName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (directoryName.length === 0) {\n      throw new Error('ArgumentException: string cannot be empty');\n    }\n\n    if (directoryName.slice(-1) !== '/') {\n      directoryName += '/';\n    }\n\n    if (this.files.indexOf(directoryName) !== -1) {\n      throw new Error('item with same name already exist');\n    }\n\n    this.files.push(directoryName);\n  };\n  /**\n   * gets item at specified index\n   * @param {number} index - item index\n   * @returns {ZipArchiveItem}\n   */\n\n\n  ZipArchive.prototype.getItem = function (index) {\n    if (index >= 0 && index < this.files.length) {\n      return this.files[index];\n    }\n\n    return undefined;\n  };\n  /**\n   * determines whether an element is in the collection\n   * @param {string | ZipArchiveItem} item - item to search\n   * @returns {boolean}\n   */\n\n\n  ZipArchive.prototype.contains = function (item) {\n    return this.files.indexOf(item) !== -1 ? true : false;\n  };\n\n  ZipArchive.prototype.open = function (base64String) {\n    //return promise = new Promise((resolve: Function, reject: Function) => {\n    var zipByteArray = Utils.encodedString(base64String);\n    if (zipByteArray.length == 0) throw new DOMException(\"stream\");\n    var stream = new Stream(zipByteArray); //let lCentralDirEndPosition = this.findValueFromEnd( arrBuffer, Constants.CentralDirectoryEndSignature, 65557 );\n\n    var lCentralDirEndPosition = ZipArchive.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);\n    if (lCentralDirEndPosition < 0) throw new DOMException(\"Can't locate end of central directory record. Possible wrong file format or archive is corrupt.\"); // Step2. Locate central directory and iterate through all items\n\n    stream.position = lCentralDirEndPosition + CentralDirSizeOffset;\n    var iCentralDirSize = ZipArchive.ReadInt32(stream);\n    var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize; // verify that this is really central directory\n\n    stream.position = lCentralDirPosition;\n    this.readCentralDirectoryDataAndExtractItems(stream); //});\n    // let zipArchive: ZipArchive = this;\n    //let promise: Promise<ZipArchive>;\n    // return promise = new Promise((resolve: Function, reject: Function) => {\n    //     let reader: FileReader = new FileReader();\n    //     reader.onload = (e: Event) => {\n    //         let data: Uint8Array = new Uint8Array((e.target as any).result);\n    //         let zipReader: ZipReader = new ZipReader(data);\n    //         zipReader.readEntries().then((entries: ZipEntry[]) => {\n    //             for (let i: number = 0; i < entries.length; i++) {\n    //                 let entry: ZipEntry = entries[i];\n    //                 let item: ZipArchiveItem = new ZipArchiveItem(zipArchive, entry.fileName);\n    //                 item.data = entry.data;\n    //                 item.compressionMethod = entry.compressionMethod;\n    //                 item.crc = entry.crc;\n    //                 item.lastModified = entry.lastModified;\n    //                 item.lastModifiedDate = entry.lastModifiedDate;\n    //                 item.size = entry.size;\n    //                 item.uncompressedSize = entry.uncompressedSize;\n    //                 zipArchive.addItem(item);\n    //             }\n    //             resolve(zipArchive);\n    //         });\n    //     };\n    //     reader.readAsArrayBuffer(fileName);\n    // });\n  }; /// <summary>\n  /// Read central directory record from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read from.</param>\n\n\n  ZipArchive.prototype.readCentralDirectoryDataAndExtractItems = function (stream) {\n    if (stream == null) throw new DOMException(\"stream\");\n    var itemHelper;\n\n    while (ZipArchive.ReadInt32(stream) == CentralHeaderSignature) {\n      itemHelper = new ZipArchiveItemHelper();\n      itemHelper.readCentralDirectoryData(stream); // let item: ZipArchiveItem = new ZipArchiveItem(this);\n      // item.ReadCentralDirectoryData(stream);\n      // m_arrItems.Add(item);\n    }\n\n    itemHelper.readData(stream, itemHelper.checkCrc);\n    itemHelper.decompressData();\n    this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));\n  };\n  /**\n   * save archive with specified file name\n   * @param {string} fileName save archive with specified file name\n   * @returns {Promise<ZipArchive>}\n   */\n\n\n  ZipArchive.prototype.save = function (fileName) {\n    if (fileName === null || fileName === undefined || fileName.length === 0) {\n      throw new Error('ArgumentException: fileName cannot be null or undefined');\n    }\n\n    if (this.files.length === 0) {\n      throw new Error('InvalidOperation');\n    }\n\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal(fileName, false).then(function () {\n        resolve(zipArchive);\n      });\n    });\n  };\n  /**\n   * Save archive as blob\n   * @return {Promise<Blob>}\n   */\n\n\n  ZipArchive.prototype.saveAsBlob = function () {\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal('', true).then(function (blob) {\n        resolve(blob);\n      });\n    });\n  };\n\n  ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n    var _this = this;\n\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      var zipData = [];\n      var dirLength = 0;\n\n      for (var i = 0; i < zipArchive.files.length; i++) {\n        var compressedObject = _this.getCompressedData(_this.files[i]);\n\n        compressedObject.then(function (data) {\n          dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n\n          if (zipData.length === zipArchive.files.length) {\n            var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n            resolve(blob);\n          }\n        });\n      }\n    });\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  ZipArchive.prototype.destroy = function () {\n    if (this.files !== undefined && this.files.length > 0) {\n      for (var i = 0; i < this.files.length; i++) {\n        var file = this.files[i];\n\n        if (file instanceof ZipArchiveItem) {\n          file.destroy();\n        }\n\n        file = undefined;\n      }\n\n      this.files = [];\n    }\n\n    this.files = undefined;\n    this.level = undefined;\n  };\n\n  ZipArchive.prototype.getCompressedData = function (item) {\n    var zipArchive = this;\n    var promise = new Promise(function (resolve, reject) {\n      if (item instanceof ZipArchiveItem) {\n        var reader_1 = new FileReader();\n\n        reader_1.onload = function () {\n          var input = new Uint8Array(reader_1.result);\n          var data = {\n            fileName: item.name,\n            crc32Value: 0,\n            compressedData: [],\n            compressedSize: undefined,\n            uncompressedDataSize: input.length,\n            compressionType: undefined,\n            isDirectory: false\n          };\n\n          if (zipArchive.level === 'Normal') {\n            zipArchive.compressData(input, data, CRC32TABLE);\n            var length_1 = 0;\n\n            for (var i = 0; i < data.compressedData.length; i++) {\n              length_1 += data.compressedData[i].length;\n            }\n\n            data.compressedSize = length_1;\n            data.compressionType = '\\x08\\x00'; //Deflated = 8\n          } else {\n            data.compressedSize = input.length;\n            data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n            data.compressionType = '\\x00\\x00'; // Stored = 0\n\n            data.compressedData.push(input);\n          }\n\n          resolve(data);\n        };\n\n        reader_1.readAsArrayBuffer(item.data);\n      } else {\n        var data = {\n          fileName: item,\n          crc32Value: 0,\n          compressedData: '',\n          compressedSize: 0,\n          uncompressedDataSize: 0,\n          compressionType: '\\x00\\x00',\n          isDirectory: true\n        };\n        resolve(data);\n      }\n    });\n    return promise;\n  };\n\n  ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n    var compressor = new CompressedStreamWriter(true);\n    var currentIndex = 0;\n    var nextIndex = 0;\n\n    do {\n      if (currentIndex >= input.length) {\n        compressor.close();\n        break;\n      }\n\n      nextIndex = Math.min(input.length, currentIndex + 16384);\n      var subArray = input.subarray(currentIndex, nextIndex);\n      data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n      compressor.write(subArray, 0, nextIndex - currentIndex);\n      currentIndex = nextIndex;\n    } while (currentIndex <= input.length);\n\n    data.compressedData = compressor.compressedData;\n    compressor.destroy();\n  };\n\n  ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n    var extFileAttr = 0;\n    var date = new Date();\n\n    if (isDirectory) {\n      extFileAttr = extFileAttr | 0x00010; // directory flag\n    }\n\n    extFileAttr = extFileAttr | 0 & 0x3F;\n    var header = this.writeHeader(data, date);\n    var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n    var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n    zipParts.push({\n      localHeader: localHeader,\n      centralDir: centralDir,\n      compressedData: data\n    });\n    return dirLength + localHeader.length + data.compressedSize;\n  };\n\n  ZipArchive.prototype.writeHeader = function (data, date) {\n    var zipHeader = '';\n    zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n\n    zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n\n    zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n\n    zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n\n    zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n\n    zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n\n    zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n\n    zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n\n    zipHeader += this.getBytes(0, 2); // extra field length\n\n    return zipHeader;\n  };\n\n  ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n    var cenDirLen = 0;\n    var buffer = [];\n\n    for (var i = 0; i < zipData.length; i++) {\n      var item = zipData[i];\n      cenDirLen += item.centralDir.length;\n      buffer.push(this.getArrayBuffer(item.localHeader));\n\n      while (item.compressedData.compressedData.length) {\n        buffer.push(item.compressedData.compressedData.shift().buffer);\n      }\n    }\n\n    for (var i = 0; i < zipData.length; i++) {\n      buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n    }\n\n    buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n    var blob = new Blob(buffer, {\n      type: 'application/zip'\n    });\n\n    if (!skipFileSave) {\n      Save.save(fileName, blob);\n    }\n\n    return blob;\n  };\n\n  ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n    var directoryHeader = 'PK\\x01\\x02' + this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n    this.getBytes(0, 2) + // comment length\n    '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n    this.getBytes(externalFileAttribute, 4) + // external file attributes\n    this.getBytes(offset, 4) + // local fileHeader relative offset\n    data.fileName;\n    return directoryHeader;\n  };\n\n  ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n    var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);\n    return dirEnd;\n  };\n\n  ZipArchive.prototype.getArrayBuffer = function (input) {\n    var a = new Uint8Array(input.length);\n\n    for (var j = 0; j < input.length; ++j) {\n      a[j] = input.charCodeAt(j) & 0xFF;\n    }\n\n    return a.buffer;\n  };\n\n  ZipArchive.prototype.getBytes = function (value, offset) {\n    var bytes = '';\n\n    for (var i = 0; i < offset; i++) {\n      bytes += String.fromCharCode(value & 0xff);\n      value = value >>> 8;\n    }\n\n    return bytes;\n  };\n\n  ZipArchive.prototype.getModifiedTime = function (date) {\n    var modTime = date.getHours();\n    modTime = modTime << 6;\n    modTime = modTime | date.getMinutes();\n    modTime = modTime << 5;\n    return modTime = modTime | date.getSeconds() / 2;\n  };\n\n  ZipArchive.prototype.getModifiedDate = function (date) {\n    var modiDate = date.getFullYear() - 1980;\n    modiDate = modiDate << 4;\n    modiDate = modiDate | date.getMonth() + 1;\n    modiDate = modiDate << 5;\n    return modiDate = modiDate | date.getDate();\n  };\n\n  ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n    crc32Value ^= -1;\n\n    for (var i = 0; i < input.length; i++) {\n      crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n    }\n\n    return crc32Value ^ -1;\n  };\n  /**\n   * construct cyclic redundancy code table\n   * @private\n   */\n\n\n  ZipArchive.initCrc32Table = function () {\n    var i;\n\n    for (var j = 0; j < 256; j++) {\n      i = j;\n\n      for (var k = 0; k < 8; k++) {\n        i = i & 1 ? 0xEDB88320 ^ i >>> 1 : i >>> 1;\n      }\n\n      CRC32TABLE[j] = i;\n    }\n  };\n\n  ZipArchive.findValueFromEnd = function (stream, value, maxCount) {\n    if (stream == null) throw new DOMException(\"stream\"); //   if( !stream.CanSeek || !stream.CanRead )\n    //     throw new ArgumentOutOfRangeException( \"We need to have seekable and readable stream.\" );\n    // read last 4 bytes and compare with required value\n\n    var lStreamSize = stream.inputStream.buffer.byteLength;\n    if (lStreamSize < 4) return -1;\n    var arrBuffer = new Uint8Array(4);\n    var lLastPos = Math.max(0, lStreamSize - maxCount);\n    var lCurrentPosition = lStreamSize - 1 - INT_SIZE;\n    stream.position = lCurrentPosition;\n    stream.read(arrBuffer, 0, INT_SIZE);\n    var uiCurValue = arrBuffer[0];\n    var bFound = uiCurValue == value;\n\n    if (!bFound) {\n      while (lCurrentPosition > lLastPos) {\n        // remove unnecessary byte and replace it with new value.\n        uiCurValue <<= 8;\n        lCurrentPosition--;\n        stream.position = lCurrentPosition;\n        uiCurValue += stream.readByte();\n\n        if (uiCurValue == value) {\n          bFound = true;\n          break;\n        }\n      }\n    }\n\n    return bFound ? lCurrentPosition : -1;\n  }; /// <summary>\n  /// Extracts Int32 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n\n\n  ZipArchive.ReadInt32 = function (stream) {\n    var buffer = new Uint8Array(INT_SIZE);\n\n    if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {\n      throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n    }\n\n    return Utils.bitConverterToInt32(buffer, 0);\n  }; /// <summary>\n  /// Extracts Int16 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n\n\n  ZipArchive.ReadInt16 = function (stream) {\n    var buffer = new Uint8Array(SHORT_SIZE);\n\n    if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n      throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n    }\n\n    return Utils.bitConverterToInt16(buffer, 0);\n  }; /// <summary>\n  /// Extracts unsigned Int16 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n\n\n  ZipArchive.ReadUInt16 = function (stream) {\n    {\n      var buffer = new Uint8Array(SHORT_SIZE);\n\n      if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n        throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n      }\n\n      return Utils.bitConverterToInt16(buffer, 0);\n    }\n  };\n\n  return ZipArchive;\n}();\n\nvar ZipArchiveItemHelper =\n/** @__PURE__ @class */\nfunction () {\n  function ZipArchiveItemHelper() {\n    /// <summary>\n    /// Zip header signature.\n    /// </summary>\n    this.headerSignature = 0x04034b50; /// <summary>\n    /// Indicates whether we should check Crc value when reading item's data. Check\n    /// is performed when user gets access to decompressed data for the first time.\n    /// </summary>\n\n    this.checkCrc = true; /// <summary>\n    /// Crc.\n    /// </summary>\n\n    this.crc32 = 0;\n  } /// <summary>\n  /// Read data from the stream based on the central directory.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from, stream.Position must point at just after correct file header.</param>\n\n\n  ZipArchiveItemHelper.prototype.readCentralDirectoryData = function (stream) {\n    // on the current moment we ignore \"version made by\" and \"version needed to extract\" fields.\n    stream.position += 4;\n    this.options = ZipArchive.ReadInt16(stream);\n    this.compressionMethod = ZipArchive.ReadInt16(stream);\n    this.checkCrc = this.compressionMethod != 99; //COmpression.Defalte != SecurityConstants.AES\n    //m_bCompressed = true;\n    // on the current moment we ignore \"last mod file time\" and \"last mod file date\" fields.\n\n    var lastModified = ZipArchive.ReadInt32(stream); //LastModified = ConvertToDateTime(lastModified);\n\n    this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));\n    this.compressedSize = ZipArchive.ReadInt32(stream);\n    this.originalSize = ZipArchive.ReadInt32(stream);\n    var iFileNameLength = ZipArchive.ReadInt16(stream);\n    var iExtraFieldLenth = ZipArchive.ReadInt16(stream);\n    var iCommentLength = ZipArchive.ReadInt16(stream); // on the current moment we ignore and \"disk number start\" (2 bytes),\n    // \"internal file attributes\" (2 bytes).\n\n    stream.position += 4;\n    this.externalAttributes = ZipArchive.ReadInt32(stream);\n    this.localHeaderOffset = ZipArchive.ReadInt32(stream);\n    var arrBuffer = new Uint8Array(iFileNameLength);\n    stream.read(arrBuffer, 0, iFileNameLength);\n    var m_strItemName = Utils.byteToString(arrBuffer);\n    m_strItemName = m_strItemName.replace(\"\\\\\", \"/\");\n    this.name = m_strItemName;\n    stream.position += iExtraFieldLenth + iCommentLength;\n    if (this.options != 0) this.options = 0;\n  }; /// <summary>\n  /// Reads zipped data from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <param name=\"checkCrc\">Indicates whether we should check crc value after data decompression.</param>\n\n\n  ZipArchiveItemHelper.prototype.readData = function (stream, checkCrc) {\n    if (stream.length == 0) throw new DOMException(\"stream\");\n    stream.position = this.localHeaderOffset;\n    this.checkCrc = checkCrc;\n    this.readLocalHeader(stream);\n    this.readCompressedData(stream);\n  };\n\n  ZipArchiveItemHelper.prototype.decompressData = function () {\n    if (this.compressionMethod == 8) {\n      if (this.originalSize > 0) {\n        this.decompressDataOld();\n      }\n    }\n  };\n\n  ZipArchiveItemHelper.prototype.decompressDataOld = function () {\n    var reader = new CompressedStreamReader(this.compressedStream, true);\n    var decompressedData;\n    if (this.originalSize > 0) decompressedData = new Stream(new Uint8Array(this.originalSize));\n    var arrBuffer = new Uint8Array(BufferSize);\n    var iReadBytes;\n\n    while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {\n      //             past = new Uint8Array(decompressedData.length);\n      // let currentBlock: Uint8Array = arrBuffer.subarray(0, iReadBytes);\n      decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);\n    }\n\n    this.unCompressedStream = decompressedData.toByteArray(); //   this.originalSize = decompressedData.Length;\n    //   m_bControlStream = true;\n    //   m_streamData = decompressedData;\n    //   decompressedData.SetLength( m_lOriginalSize );\n    //   decompressedData.Capacity = ( int )m_lOriginalSize;\n\n    if (this.checkCrc) {//TODO: fix this\n      //CheckCrc(decompressedData.ToArray());\n    } //m_streamData.Position = 0;\n\n  }; /// <summary>\n  /// Extracts local header from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n\n\n  ZipArchiveItemHelper.prototype.readLocalHeader = function (stream) {\n    if (stream.length == 0) throw new DOMException(\"stream\");\n    if (ZipArchive.ReadInt32(stream) != this.headerSignature) throw new DOMException(\"Can't find local header signature - wrong file format or file is corrupt.\"); // TODO: it is good to verify data read from the central directory record,\n    // but on the current moment we simply skip it.\n\n    stream.position += 22;\n    var iNameLength = ZipArchive.ReadInt16(stream);\n    var iExtraLength = ZipArchive.ReadUInt16(stream);\n\n    if (this.compressionMethod == 99) //SecurityConstants.AES\n      {// stream.Position += iNameLength + 8;\n        // m_archive.EncryptionAlgorithm = (EncryptionAlgorithm)stream.ReadByte();\n        // m_actualCompression = new byte[2];\n        // stream.Read(m_actualCompression, 0, 2);\n      } else if (iExtraLength > 2) {\n      stream.position += iNameLength;\n      var headerVal = ZipArchive.ReadInt16(stream);\n      if (headerVal == 0x0017) //PKZipEncryptionHeader\n        throw new DOMException(\"UnSupported\");else stream.position += iExtraLength - 2;\n    } else stream.position += iNameLength + iExtraLength;\n  }; /// <summary>\n  /// Extracts compressed data from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n\n\n  ZipArchiveItemHelper.prototype.readCompressedData = function (stream) {\n    var dataStream;\n\n    if (this.compressedSize > 0) {\n      var iBytesLeft = this.compressedSize;\n      dataStream = new Stream(new Uint8Array(iBytesLeft));\n      var arrBuffer = new Uint8Array(BufferSize);\n\n      while (iBytesLeft > 0) {\n        var iBytesToRead = Math.min(iBytesLeft, BufferSize);\n        if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead) throw new DOMException(\"End of file reached - wrong file format or file is corrupt.\");\n        dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);\n        iBytesLeft -= iBytesToRead;\n      } // if(m_archive.Password != null)\n      // {\n      //     byte[] dataBuffer = new byte[dataStream.Length];\n      //     dataBuffer = dataStream.ToArray();\n      //     dataStream=new MemoryStream( Decrypt(dataBuffer));\n      // }\n\n\n      this.compressedStream = new Uint8Array(dataStream.inputStream); // m_bControlStream = true;\n    } else if (this.compressedSize < 0) //If compression size is negative, then read until the next header signature reached.\n      {//   MemoryStream dataStream = new MemoryStream();\n        //   int bt = 0;\n        //   bool proceed=true;\n        //   while (proceed)\n        //   {\n        //       if ((bt = stream.ReadByte()) == Constants.HeaderSignatureStartByteValue)\n        //       {\n        //           stream.Position -= 1;\n        //           int headerSignature = ZipArchive.ReadInt32(stream);\n        //           if (headerSignature==Constants.CentralHeaderSignature || headerSignature==Constants.CentralHeaderSignature)\n        //           {\n        //               proceed = false;\n        //           }\n        //           stream.Position -= 3;\n        //       }\n        //       if (proceed)\n        //           dataStream.WriteByte((byte)bt);\n        //   }\n        //   m_streamData = dataStream;\n        //   m_lCompressedSize = m_streamData.Length;\n        //   m_bControlStream = true;\n      } else if (this.compressedSize == 0) {//  m_streamData = new MemoryStream();\n    }\n  };\n\n  return ZipArchiveItemHelper;\n}();\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\n\n\nvar ZipArchiveItem =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * constructor for creating {ZipArchiveItem} instance\n   * @param {Blob|ArrayBuffer} data file data\n   * @param {itemName} itemName absolute file path\n   */\n  function ZipArchiveItem(data, itemName) {\n    if (data === null || data === undefined) {\n      throw new Error('ArgumentException: data cannot be null or undefined');\n    }\n\n    if (itemName === null || itemName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (itemName.length === 0) {\n      throw new Error('string cannot be empty');\n    }\n\n    this.data = data;\n    this.name = itemName;\n  }\n\n  Object.defineProperty(ZipArchiveItem.prototype, \"dataStream\", {\n    get: function () {\n      return this.decompressedStream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n    /**\n     * Get the name of archive item\n     * @returns string\n     */\n    get: function () {\n      return this.fileName;\n    },\n\n    /**\n     * Set the name of archive item\n     * @param  {string} value\n     */\n    set: function (value) {\n      this.fileName = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n  ZipArchiveItem.prototype.destroy = function () {\n    this.fileName = undefined;\n    this.data = undefined;\n  };\n\n  return ZipArchiveItem;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n\n/**\n * array literal codes\n */\n\n\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\n\nvar CompressedStreamWriter =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  function CompressedStreamWriter(noWrap) {\n    this.pendingBuffer = new Uint8Array(1 << 16);\n    this.pendingBufLength = 0;\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.currentHash = 0;\n    this.matchStart = 0;\n    this.matchLength = 0;\n    this.matchPrevAvail = false;\n    this.blockStart = 0;\n    this.stringStart = 0;\n    this.lookAhead = 0;\n    this.totalBytesIn = 0;\n    this.inputOffset = 0;\n    this.inputEnd = 0;\n    this.windowSize = 1 << 15;\n    this.windowMask = this.windowSize - 1;\n    this.hashSize = 1 << 15;\n    this.hashMask = this.hashSize - 1;\n    this.hashShift = Math.floor((15 + 3 - 1) / 3);\n    this.maxDist = this.windowSize - 262;\n    this.checkSum = 1;\n    this.noWrap = false;\n\n    if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n      CompressedStreamWriter.initHuffmanTree();\n      CompressedStreamWriter.isHuffmanTreeInitiated = true;\n    }\n\n    this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n    this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n    this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n    this.arrDistances = new Uint16Array(1 << 14);\n    this.arrLiterals = new Uint8Array(1 << 14);\n    this.stream = [];\n    this.dataWindow = new Uint8Array(2 * this.windowSize);\n    this.hashHead = new Int16Array(this.hashSize);\n    this.hashPrevious = new Int16Array(this.windowSize);\n    this.blockStart = this.stringStart = 1;\n    this.noWrap = noWrap;\n\n    if (!noWrap) {\n      this.writeZLibHeader();\n    }\n  }\n\n  Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n    /**\n     * get compressed data\n     */\n    get: function () {\n      return this.stream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n    get: function () {\n      var compressedString = '';\n\n      if (this.stream !== undefined) {\n        for (var i = 0; i < this.stream.length; i++) {\n          compressedString += String.fromCharCode.apply(null, this.stream[i]);\n        }\n      }\n\n      return compressedString;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Compresses data and writes it to the stream.\n   * @param {Uint8Array} data - data to compress\n   * @param {number} offset - offset in data\n   * @param {number} length - length of the data\n   * @returns {void}\n   */\n\n  CompressedStreamWriter.prototype.write = function (data, offset, length) {\n    if (data === undefined || data === null) {\n      throw new Error('ArgumentException: data cannot null or undefined');\n    }\n\n    var end = offset + length;\n\n    if (0 > offset || offset > end || end > data.length) {\n      throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n    }\n\n    if (typeof data === 'string') {\n      var encode = new Encoding(false);\n      encode.type = 'Utf8';\n      data = new Uint8Array(encode.getBytes(data, 0, data.length));\n      end = offset + data.length;\n    }\n\n    this.inputBuffer = data;\n    this.inputOffset = offset;\n    this.inputEnd = end;\n\n    if (!this.noWrap) {\n      this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n    }\n\n    while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n      this.pendingBufferFlush();\n      this.compressData(false);\n    }\n  };\n  /**\n   * write ZLib header to the compressed data\n   * @return {void}\n   */\n\n\n  CompressedStreamWriter.prototype.writeZLibHeader = function () {\n    /* Initialize header.*/\n    var headerDate = 8 + (7 << 4) << 8;\n    /* Save compression level.*/\n\n    headerDate |= (5 >> 2 & 3) << 6;\n    /* Align header.*/\n\n    headerDate += 31 - headerDate % 31;\n    /* Write header to stream.*/\n\n    this.pendingBufferWriteShortBytes(headerDate);\n  };\n  /**\n   *  Write Most Significant Bytes in to stream\n   * @param {number} s - check sum value\n   */\n\n\n  CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n    this.pendingBuffer[this.pendingBufLength++] = s;\n  };\n\n  CompressedStreamWriter.prototype.compressData = function (finish) {\n    var success;\n\n    do {\n      this.fillWindow();\n      var canFlush = finish && this.inputEnd === this.inputOffset;\n      success = this.compressSlow(canFlush, finish);\n    } while (this.pendingBufLength === 0 && success);\n\n    return success;\n  };\n\n  CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n    if (this.lookAhead < 262 && !flush) {\n      return false;\n    }\n\n    while (this.lookAhead >= 262 || flush) {\n      if (this.lookAhead === 0) {\n        return this.lookAheadCompleted(finish);\n      }\n\n      if (this.stringStart >= 2 * this.windowSize - 262) {\n        this.slideWindow();\n      }\n\n      var prevMatch = this.matchStart;\n      var prevLen = this.matchLength;\n\n      if (this.lookAhead >= 3) {\n        this.discardMatch();\n      }\n\n      if (prevLen >= 3 && this.matchLength <= prevLen) {\n        prevLen = this.matchPreviousBest(prevMatch, prevLen);\n      } else {\n        this.matchPreviousAvailable();\n      }\n\n      if (this.bufferPosition >= 1 << 14) {\n        return this.huffmanIsFull(finish);\n      }\n    }\n\n    return true;\n  };\n\n  CompressedStreamWriter.prototype.discardMatch = function () {\n    var hashHead = this.insertString();\n\n    if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n      if (this.matchLength <= 5 && this.matchLength === 3 && this.stringStart - this.matchStart > 4096) {\n        this.matchLength = 3 - 1;\n      }\n    }\n  };\n\n  CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = true;\n    this.stringStart++;\n    this.lookAhead--;\n  };\n\n  CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n    this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n    prevLen -= 2;\n\n    do {\n      this.stringStart++;\n      this.lookAhead--;\n\n      if (this.lookAhead >= 3) {\n        this.insertString();\n      }\n    } while (--prevLen > 0);\n\n    this.stringStart++;\n    this.lookAhead--;\n    this.matchPrevAvail = false;\n    this.matchLength = 3 - 1;\n    return prevLen;\n  };\n\n  CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = false;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n    this.blockStart = this.stringStart;\n    return false;\n  };\n\n  CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n    var len = this.stringStart - this.blockStart;\n\n    if (this.matchPrevAvail) {\n      len--;\n    }\n\n    var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n    this.blockStart += len;\n    return !lastBlock;\n  };\n\n  CompressedStreamWriter.prototype.fillWindow = function () {\n    if (this.stringStart >= this.windowSize + this.maxDist) {\n      this.slideWindow();\n    }\n\n    while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n      var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n\n      if (more > this.inputEnd - this.inputOffset) {\n        more = this.inputEnd - this.inputOffset;\n      }\n\n      this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n      this.inputOffset += more;\n      this.totalBytesIn += more;\n      this.lookAhead += more;\n    }\n\n    if (this.lookAhead >= 3) {\n      this.updateHash();\n    }\n  };\n\n  CompressedStreamWriter.prototype.slideWindow = function () {\n    this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n    this.matchStart -= this.windowSize;\n    this.stringStart -= this.windowSize;\n    this.blockStart -= this.windowSize;\n\n    for (var i = 0; i < this.hashSize; ++i) {\n      var m = this.hashHead[i] & 0xffff;\n      this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n\n    for (var i = 0; i < this.windowSize; i++) {\n      var m = this.hashPrevious[i] & 0xffff;\n      this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n  };\n\n  CompressedStreamWriter.prototype.insertString = function () {\n    var match;\n    var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n    this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n    this.hashHead[hash] = this.stringStart;\n    this.currentHash = hash;\n    return match & 0xffff;\n  };\n\n  CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n    var chainLen = 4096;\n    var niceLen = 258;\n    var scan = this.stringStart;\n    var match;\n    var bestEnd = this.stringStart + this.matchLength;\n    var bestLength = Math.max(this.matchLength, 3 - 1);\n    var limit = Math.max(this.stringStart - this.maxDist, 0);\n    var stringEnd = this.stringStart + 258 - 1;\n    var scanEnd1 = this.dataWindow[bestEnd - 1];\n    var scanEnd = this.dataWindow[bestEnd];\n    var data = this.dataWindow;\n\n    if (bestLength >= 32) {\n      chainLen >>= 2;\n    }\n\n    if (niceLen > this.lookAhead) {\n      niceLen = this.lookAhead;\n    }\n\n    do {\n      if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {\n        continue;\n      }\n\n      match = curMatch + 2;\n      scan += 2;\n      /* tslint:disable */\n\n      while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n        /* tslint:disable */\n      }\n\n      if (scan > bestEnd) {\n        this.matchStart = curMatch;\n        bestEnd = scan;\n        bestLength = scan - this.stringStart;\n\n        if (bestLength >= niceLen) {\n          break;\n        }\n\n        scanEnd1 = data[bestEnd - 1];\n        scanEnd = data[bestEnd];\n      }\n\n      scan = this.stringStart;\n    } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 0xffff) > limit && --chainLen !== 0);\n\n    this.matchLength = Math.min(bestLength, this.lookAhead);\n    return this.matchLength >= 3;\n  };\n\n  CompressedStreamWriter.prototype.updateHash = function () {\n    this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];\n  };\n\n  CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n    this.arrDistances[this.bufferPosition] = 0;\n    this.arrLiterals[this.bufferPosition++] = literal;\n    this.treeLiteral.codeFrequencies[literal]++;\n    return this.bufferPosition >= 1 << 14;\n  };\n\n  CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n    this.arrDistances[this.bufferPosition] = dist;\n    this.arrLiterals[this.bufferPosition++] = len - 3;\n    var lc = this.huffmanLengthCode(len - 3);\n    this.treeLiteral.codeFrequencies[lc]++;\n\n    if (lc >= 265 && lc < 285) {\n      this.extraBits += Math.floor((lc - 261) / 4);\n    }\n\n    var dc = this.huffmanDistanceCode(dist - 1);\n    this.treeDistances.codeFrequencies[dc]++;\n\n    if (dc >= 4) {\n      this.extraBits += Math.floor(dc / 2 - 1);\n    }\n\n    return this.bufferPosition >= 1 << 14;\n  };\n\n  CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.treeLiteral.codeFrequencies[256]++;\n    this.treeLiteral.buildTree();\n    this.treeDistances.buildTree();\n    this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n    this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n    this.treeCodeLengths.buildTree();\n    var blTreeCodes = 4;\n\n    for (var i = 18; i > blTreeCodes; i--) {\n      if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n        blTreeCodes = i + 1;\n      }\n    }\n\n    var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n    var static_len = this.extraBits;\n\n    for (var i = 0; i < 286; i++) {\n      static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n    }\n\n    for (var i = 0; i < 30; i++) {\n      static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n    }\n\n    if (opt_len >= static_len) {\n      // Force static trees.\n      opt_len = static_len;\n    }\n\n    if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n      this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n    } else if (opt_len == static_len) {\n      // Encode with static tree.\n      this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n      this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n      this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    } else {\n      this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n      this.huffmanSendAllTrees(blTreeCodes);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    }\n  };\n\n  CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n    this.pendingBufferAlignToByte();\n    this.pendingBufferWriteShort(storedLength);\n    this.pendingBufferWriteShort(~storedLength);\n    this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n    this.huffmanReset();\n  };\n\n  CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n    if (len === 255) {\n      return 285;\n    }\n\n    var code = 257;\n\n    while (len >= 8) {\n      code += 4;\n      len >>= 1;\n    }\n\n    return code + len;\n  };\n\n  CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n    var code = 0;\n\n    while (distance >= 4) {\n      code += 2;\n      distance >>= 1;\n    }\n\n    return code + distance;\n  };\n\n  CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n    this.treeCodeLengths.buildCodes();\n    this.treeLiteral.buildCodes();\n    this.treeDistances.buildCodes();\n    this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n    this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n    this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n\n    for (var rank = 0; rank < blTreeCodes; rank++) {\n      this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n    }\n\n    this.treeLiteral.writeTree(this.treeCodeLengths);\n    this.treeDistances.writeTree(this.treeCodeLengths);\n  };\n\n  CompressedStreamWriter.prototype.huffmanReset = function () {\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.treeLiteral.reset();\n    this.treeDistances.reset();\n    this.treeCodeLengths.reset();\n  };\n\n  CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n    for (var i = 0; i < this.bufferPosition; i++) {\n      var literalLen = this.arrLiterals[i] & 255;\n      var dist = this.arrDistances[i];\n\n      if (dist-- !== 0) {\n        var lc = this.huffmanLengthCode(literalLen);\n        this.treeLiteral.writeCodeToStream(lc);\n        var bits = Math.floor((lc - 261) / 4);\n\n        if (bits > 0 && bits <= 5) {\n          this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);\n        }\n\n        var dc = this.huffmanDistanceCode(dist);\n        this.treeDistances.writeCodeToStream(dc);\n        bits = Math.floor(dc / 2 - 1);\n\n        if (bits > 0) {\n          this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);\n        }\n      } else {\n        this.treeLiteral.writeCodeToStream(literalLen);\n      }\n    }\n\n    this.treeLiteral.writeCodeToStream(256);\n  };\n  /**\n   * write bits in to internal buffer\n   * @param {number} b - source of bits\n   * @param {number} count - count of bits to write\n   */\n\n\n  CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n    var uint = new Uint32Array(1);\n    uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;\n    this.pendingBufCache = uint[0];\n    this.pendingBufBitsInCache += count;\n    this.pendingBufferFlushBits();\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n    this.pendingBufferFlushBits();\n\n    if (this.pendingBufLength > 0) {\n      var array = new Uint8Array(this.pendingBufLength);\n      array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n      this.stream.push(array);\n    }\n\n    this.pendingBufLength = 0;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n    var result = 0;\n\n    while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n      this.pendingBufCache >>= 8;\n      this.pendingBufBitsInCache -= 8;\n      result++;\n    }\n\n    return result;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n    var array = data.subarray(offset, offset + length);\n    this.pendingBuffer.set(array, this.pendingBufLength);\n    this.pendingBufLength += length;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s;\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n    if (this.pendingBufBitsInCache > 0) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n    }\n\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n  };\n  /**\n   * Huffman Tree literal calculation\n   * @private\n   */\n\n\n  CompressedStreamWriter.initHuffmanTree = function () {\n    var i = 0;\n\n    while (i < 144) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x030 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    while (i < 256) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x190 - 144 + i << 7);\n      ARR_LITERAL_LENGTHS[i++] = 9;\n    }\n\n    while (i < 280) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x000 - 256 + i << 9);\n      ARR_LITERAL_LENGTHS[i++] = 7;\n    }\n\n    while (i < 286) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x0c0 - 280 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    for (i = 0; i < 30; i++) {\n      ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n      ARR_DISTANCE_LENGTHS[i] = 5;\n    }\n  };\n  /**\n   * close the stream and write all pending buffer in to stream\n   * @returns {void}\n   */\n\n\n  CompressedStreamWriter.prototype.close = function () {\n    do {\n      this.pendingBufferFlush(true);\n\n      if (!this.compressData(true)) {\n        this.pendingBufferFlush(true);\n        this.pendingBufferAlignToByte();\n\n        if (!this.noWrap) {\n          this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n          this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n        }\n\n        this.pendingBufferFlush(true);\n      }\n    } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  CompressedStreamWriter.prototype.destroy = function () {\n    this.stream = [];\n    this.stream = undefined;\n    this.pendingBuffer = undefined;\n    this.treeLiteral = undefined;\n    this.treeDistances = undefined;\n    this.treeCodeLengths = undefined;\n    this.arrLiterals = undefined;\n    this.arrDistances = undefined;\n    this.hashHead = undefined;\n    this.hashPrevious = undefined;\n    this.dataWindow = undefined;\n    this.inputBuffer = undefined;\n    this.pendingBufLength = undefined;\n    this.pendingBufCache = undefined;\n    this.pendingBufBitsInCache = undefined;\n    this.bufferPosition = undefined;\n    this.extraBits = undefined;\n    this.currentHash = undefined;\n    this.matchStart = undefined;\n    this.matchLength = undefined;\n    this.matchPrevAvail = undefined;\n    this.blockStart = undefined;\n    this.stringStart = undefined;\n    this.lookAhead = undefined;\n    this.totalBytesIn = undefined;\n    this.inputOffset = undefined;\n    this.inputEnd = undefined;\n    this.windowSize = undefined;\n    this.windowMask = undefined;\n    this.hashSize = undefined;\n    this.hashMask = undefined;\n    this.hashShift = undefined;\n    this.maxDist = undefined;\n    this.checkSum = undefined;\n    this.noWrap = undefined;\n  };\n\n  CompressedStreamWriter.isHuffmanTreeInitiated = false;\n  return CompressedStreamWriter;\n}();\n/**\n * represent the Huffman Tree\n */\n\n\nvar CompressorHuffmanTree =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Create new Huffman Tree\n   * @param {CompressedStreamWriter} writer instance\n   * @param {number} elementCount - element count\n   * @param {number} minCodes - minimum count\n   * @param {number} maxLength - maximum count\n   */\n  function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n    this.writer = writer;\n    this.codeMinCount = minCodes;\n    this.maxLength = maxLength;\n    this.codeFrequency = new Uint16Array(elementCount);\n    this.lengthCount = new Int32Array(maxLength);\n  }\n\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n    get: function () {\n      return this.codeCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n    get: function () {\n      return this.codeLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n    get: function () {\n      return this.codeFrequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n    var temp = new Int16Array(codes.length);\n    temp.set(codes, 0);\n    this.codes = temp;\n    var lengthTemp = new Uint8Array(lengths.length);\n    lengthTemp.set(lengths, 0);\n    this.codeLength = lengthTemp;\n  };\n  /**\n   * reset all code data in tree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.reset = function () {\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      this.codeFrequency[i] = 0;\n    }\n\n    this.codes = undefined;\n    this.codeLength = undefined;\n  };\n  /**\n   * write code to the compressor output stream\n   * @param {number} code - code to be written\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n    this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n  };\n  /**\n   * calculate code from their frequencies\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.buildCodes = function () {\n    var nextCode = new Int32Array(this.maxLength);\n    this.codes = new Int16Array(this.codeCount);\n    var code = 0;\n\n    for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n      nextCode[bitsCount] = code;\n      code += this.lengthCount[bitsCount] << 15 - bitsCount;\n    }\n\n    for (var i = 0; i < this.codeCount; i++) {\n      var bits = this.codeLength[i];\n\n      if (bits > 0) {\n        this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n        nextCode[bits - 1] += 1 << 16 - bits;\n      }\n    }\n  };\n\n  CompressorHuffmanTree.bitReverse = function (value) {\n    return CompressorHuffmanTree.reverseBits[value & 15] << 12 | CompressorHuffmanTree.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree.reverseBits[value >> 12];\n  };\n  /**\n   * calculate length of compressed data\n   * @returns {number}\n   */\n\n\n  CompressorHuffmanTree.prototype.getEncodedLength = function () {\n    var len = 0;\n\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      len += this.codeFrequency[i] * this.codeLength[i];\n    }\n\n    return len;\n  };\n  /**\n   * calculate code frequencies\n   * @param {CompressorHuffmanTree} blTree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n    var maxCount;\n    var minCount;\n    var count;\n    var curLen = -1;\n    var i = 0;\n\n    while (i < this.codeCount) {\n      count = 1;\n      var nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxCount = 138;\n        minCount = 3;\n      } else {\n        maxCount = 6;\n        minCount = 3;\n\n        if (curLen !== nextLen) {\n          blTree.codeFrequency[nextLen]++;\n          count = 0;\n        }\n      }\n\n      curLen = nextLen;\n      i++;\n\n      while (i < this.codeCount && curLen === this.codeLength[i]) {\n        i++;\n\n        if (++count >= maxCount) {\n          break;\n        }\n      }\n\n      if (count < minCount) {\n        blTree.codeFrequency[curLen] += count;\n      } else if (curLen !== 0) {\n        blTree.codeFrequency[16]++;\n      } else if (count <= 10) {\n        blTree.codeFrequency[17]++;\n      } else {\n        blTree.codeFrequency[18]++;\n      }\n    }\n  };\n  /**\n   * @param {CompressorHuffmanTree} blTree - write tree to output stream\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n    var maxRepeatCount;\n    var minRepeatCount;\n    var currentRepeatCount;\n    var currentCodeLength = -1;\n    var i = 0;\n\n    while (i < this.codeCount) {\n      currentRepeatCount = 1;\n      var nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxRepeatCount = 138;\n        minRepeatCount = 3;\n      } else {\n        maxRepeatCount = 6;\n        minRepeatCount = 3;\n\n        if (currentCodeLength !== nextLen) {\n          blTree.writeCodeToStream(nextLen);\n          currentRepeatCount = 0;\n        }\n      }\n\n      currentCodeLength = nextLen;\n      i++;\n\n      while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n        i++;\n\n        if (++currentRepeatCount >= maxRepeatCount) {\n          break;\n        }\n      }\n\n      if (currentRepeatCount < minRepeatCount) {\n        while (currentRepeatCount-- > 0) {\n          blTree.writeCodeToStream(currentCodeLength);\n        }\n      } else if (currentCodeLength !== 0) {\n        blTree.writeCodeToStream(16);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n      } else if (currentRepeatCount <= 10) {\n        blTree.writeCodeToStream(17);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n      } else {\n        blTree.writeCodeToStream(18);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n      }\n    }\n  };\n  /**\n   * Build huffman tree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.buildTree = function () {\n    var codesCount = this.codeFrequency.length;\n    var arrTree = new Int32Array(codesCount);\n    var treeLength = 0;\n    var maxCount = 0;\n\n    for (var n = 0; n < codesCount; n++) {\n      var freq = this.codeFrequency[n];\n\n      if (freq !== 0) {\n        var pos = treeLength++;\n        var pPos = 0;\n\n        while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n          arrTree[pos] = arrTree[pPos];\n          pos = pPos;\n        }\n\n        arrTree[pos] = n;\n        maxCount = n;\n      }\n    }\n\n    while (treeLength < 2) {\n      arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;\n    }\n\n    this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n    var leafsCount = treeLength;\n    var nodesCount = leafsCount;\n    var child = new Int32Array(4 * treeLength - 2);\n    var values = new Int32Array(2 * treeLength - 1);\n\n    for (var i = 0; i < treeLength; i++) {\n      var node = arrTree[i];\n      var iIndex = 2 * i;\n      child[iIndex] = node;\n      child[iIndex + 1] = -1;\n      values[i] = this.codeFrequency[node] << 8;\n      arrTree[i] = i;\n    }\n\n    this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n    this.buildLength(child);\n  };\n\n  CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n    do {\n      var first = arrTree[0];\n      var last = arrTree[--treeLength];\n      var lastVal = values[last];\n      var pPos = 0;\n      var path = 1;\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n      var second = arrTree[0];\n      last = nodesCount++;\n      child[2 * last] = first;\n      child[2 * last + 1] = second;\n      var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n      values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n      pPos = 0;\n      path = 1;\n      /* tslint:disable */\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n      /* tslint:disable */\n\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n    } while (treeLength > 1);\n  };\n\n  CompressorHuffmanTree.prototype.buildLength = function (child) {\n    this.codeLength = new Uint8Array(this.codeFrequency.length);\n    var numNodes = Math.floor(child.length / 2);\n    var numLeafs = Math.floor((numNodes + 1) / 2);\n    var overflow = 0;\n\n    for (var i = 0; i < this.maxLength; i++) {\n      this.lengthCount[i] = 0;\n    }\n\n    overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n\n    if (overflow === 0) {\n      return;\n    }\n\n    var iIncreasableLength = this.maxLength - 1;\n\n    do {\n      while (this.lengthCount[--iIncreasableLength] === 0) {\n        /* tslint:disable */\n      }\n\n      do {\n        this.lengthCount[iIncreasableLength]--;\n        this.lengthCount[++iIncreasableLength]++;\n        overflow -= 1 << this.maxLength - 1 - iIncreasableLength;\n      } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n    } while (overflow > 0);\n\n    this.recreateTree(child, overflow, numLeafs);\n  };\n\n  CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n    this.lengthCount[this.maxLength - 1] += overflow;\n    this.lengthCount[this.maxLength - 2] -= overflow;\n    var nodePtr = 2 * numLeafs;\n\n    for (var bits = this.maxLength; bits !== 0; bits--) {\n      var n = this.lengthCount[bits - 1];\n\n      while (n > 0) {\n        var childPtr = 2 * child[nodePtr++];\n\n        if (child[childPtr + 1] === -1) {\n          this.codeLength[child[childPtr]] = bits;\n          n--;\n        }\n      }\n    }\n  };\n\n  CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n    var lengths = new Int32Array(numNodes);\n    lengths[numNodes - 1] = 0;\n\n    for (var i = numNodes - 1; i >= 0; i--) {\n      var childIndex = 2 * i + 1;\n\n      if (child[childIndex] !== -1) {\n        var bitLength = lengths[i] + 1;\n\n        if (bitLength > this.maxLength) {\n          bitLength = this.maxLength;\n          overflow++;\n        }\n\n        lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n      } else {\n        var bitLength = lengths[i];\n        this.lengthCount[bitLength - 1]++;\n        this.codeLength[child[childIndex - 1]] = lengths[i];\n      }\n    }\n\n    return overflow;\n  };\n\n  CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n  CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  return CompressorHuffmanTree;\n}();\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\n\n\nvar ChecksumCalculator =\n/** @__PURE__ @class */\nfunction () {\n  function ChecksumCalculator() {}\n  /**\n   * Updates checksum by calculating checksum of the\n   * given buffer and adding it to current value.\n   * @param {number} checksum - current checksum.\n   * @param {Uint8Array} buffer - data byte array.\n   * @param {number} offset - offset in the buffer.\n   * @param {number} length - length of data to be used from the stream.\n   * @returns {number}\n   */\n\n\n  ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n    var uint = new Uint32Array(1);\n    uint[0] = checksum;\n    var checksum_uint = uint[0];\n    var s1 = uint[0] = checksum_uint & 65535;\n    var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n\n    while (length > 0) {\n      var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n      length -= steps;\n\n      while (--steps >= 0) {\n        s1 = s1 + (uint[0] = buffer[offset++] & 255);\n        s2 = s2 + s1;\n      }\n\n      s1 %= ChecksumCalculator.checksumBase;\n      s2 %= ChecksumCalculator.checksumBase;\n    }\n\n    checksum_uint = s2 << ChecksumCalculator.checkSumBitOffset | s1;\n    return checksum_uint;\n  };\n\n  ChecksumCalculator.checkSumBitOffset = 16;\n  ChecksumCalculator.checksumBase = 65521;\n  ChecksumCalculator.checksumIterationCount = 3800;\n  return ChecksumCalculator;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n\n\nvar DecompressorHuffmanTree =\n/** @__PURE__ @class */\nfunction () {\n  function DecompressorHuffmanTree(lengths) {\n    this.buildTree(lengths);\n  }\n\n  DecompressorHuffmanTree.init = function () {\n    var lengths;\n    var index; // Generate huffman tree for lengths.\n\n    lengths = new Uint8Array(288);\n    index = 0;\n\n    while (index < 144) {\n      lengths[index++] = 8;\n    }\n\n    while (index < 256) {\n      lengths[index++] = 9;\n    }\n\n    while (index < 280) {\n      lengths[index++] = 7;\n    }\n\n    while (index < 288) {\n      lengths[index++] = 8;\n    }\n\n    DecompressorHuffmanTree.m_LengthTree = new DecompressorHuffmanTree(lengths); // Generate huffman tree for distances.\n\n    lengths = new Uint8Array(32);\n    index = 0;\n\n    while (index < 32) {\n      lengths[index++] = 5;\n    }\n\n    DecompressorHuffmanTree.m_DistanceTree = new DecompressorHuffmanTree(lengths);\n  }; /// <summary>\n  /// Prepares data for generating huffman tree.\n  /// </summary>\n  /// <param name=\"blCount\">Array of counts of each code length.</param>\n  /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n  /// <param name=\"treeSize\">Calculated tree size.</param>\n  /// <returns>Code.</returns>\n\n\n  DecompressorHuffmanTree.prototype.prepareData = function (blCount, nextCode, lengths) {\n    var code = 0;\n    var treeSize = 512; // Count number of codes for each code length.\n\n    for (var i = 0; i < lengths.length; i++) {\n      var length_1 = lengths[i];\n\n      if (length_1 > 0) {\n        blCount[length_1]++;\n      }\n    }\n\n    for (var bits = 1; bits <= DecompressorHuffmanTree.MAX_BITLEN; bits++) {\n      nextCode[bits] = code;\n      code += blCount[bits] << 16 - bits;\n\n      if (bits >= 10) {\n        var start = nextCode[bits] & 0x1ff80;\n        var end = code & 0x1ff80;\n        treeSize += end - start >> 16 - bits;\n      }\n    }\n    /*      if( code != 65536 )\n      throw new ZipException( \"Code lengths don't add up properly.\" );*/\n\n\n    return {\n      'code': code,\n      'treeSize': treeSize\n    };\n  }; /// <summary>\n  /// Generates huffman tree.\n  /// </summary>\n  /// <param name=\"blCount\">Array of counts of each code length.</param>\n  /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n  /// <param name=\"code\">Precalculated code.</param>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n  /// <param name=\"treeSize\">Calculated size of the tree.</param>\n  /// <returns>Generated tree.</returns>\n\n\n  DecompressorHuffmanTree.prototype.treeFromData = function (blCount, nextCode, lengths, code, treeSize) {\n    var tree = new Int16Array(treeSize);\n    var pointer = 512;\n    var increment = 1 << 7;\n\n    for (var bits = DecompressorHuffmanTree.MAX_BITLEN; bits >= 10; bits--) {\n      var end = code & 0x1ff80;\n      code -= blCount[bits] << 16 - bits;\n      var start = code & 0x1ff80;\n\n      for (var i = start; i < end; i += increment) {\n        tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16(-pointer << 4 | bits);\n        pointer += 1 << bits - 9;\n      }\n    }\n\n    for (var i = 0; i < lengths.length; i++) {\n      var bits = lengths[i];\n\n      if (bits == 0) {\n        continue;\n      }\n\n      code = nextCode[bits];\n      var revcode = Utils.bitReverse(code);\n\n      if (bits <= 9) {\n        do {\n          tree[revcode] = Utils.bitConverterInt32ToInt16(i << 4 | bits);\n          revcode += 1 << bits;\n        } while (revcode < 512);\n      } else {\n        var subTree = tree[revcode & 511];\n        var treeLen = 1 << (subTree & 15);\n        subTree = -(subTree >> 4);\n\n        do {\n          tree[subTree | revcode >> 9] = Utils.bitConverterInt32ToInt16(i << 4 | bits);\n          revcode += 1 << bits;\n        } while (revcode < treeLen);\n      }\n\n      nextCode[bits] = code + (1 << 16 - bits);\n    }\n\n    return tree;\n  }; /// <summary>\n  /// Builds huffman tree from array of code lengths.\n  /// </summary>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n\n\n  DecompressorHuffmanTree.prototype.buildTree = function (lengths) {\n    // Count of codes for each code length.\n    var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Numerical value of the smallest code for each code length.\n\n    var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var prepareData = this.prepareData(blCount, nextCode, lengths);\n    this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);\n  }; /// <summary>\n  /// Reads and decompresses one symbol.\n  /// </summary>\n  /// <param name=\"input\"></param>\n  /// <returns></returns>\n\n\n  DecompressorHuffmanTree.prototype.unpackSymbol = function (input) {\n    var lookahead;\n    var symbol;\n\n    if ((lookahead = input.peekBits(9)) >= 0) {\n      if ((symbol = this.m_Tree[lookahead]) >= 0) {\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      }\n\n      var subtree = -(symbol >> 4);\n      var bitlen = symbol & 15;\n\n      if ((lookahead = input.peekBits(bitlen)) >= 0) {\n        symbol = this.m_Tree[subtree | lookahead >> 9];\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      } else {\n        var bits = input.availableBits;\n        lookahead = input.peekBits(bits);\n        symbol = this.m_Tree[subtree | lookahead >> 9];\n\n        if ((symbol & 15) <= bits) {\n          input.skipBits(symbol & 15);\n          return symbol >> 4;\n        } else {\n          return -1;\n        }\n      }\n    } else {\n      var bits = input.availableBits;\n      lookahead = input.peekBits(bits);\n      symbol = this.m_Tree[lookahead];\n\n      if (symbol >= 0 && (symbol & 15) <= bits) {\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      } else {\n        return -1;\n      }\n    }\n  };\n\n  Object.defineProperty(DecompressorHuffmanTree, \"lengthTree\", {\n    /// <summary>\n    /// GET huffman tree for encoding and decoding lengths.\n    /// </summary>\n    get: function () {\n      return this.m_LengthTree;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DecompressorHuffmanTree, \"distanceTree\", {\n    /// <summary>\n    /// GET huffman tree for encoding and decoding distances.\n    /// </summary>\n    get: function () {\n      return this.m_DistanceTree;\n    },\n    enumerable: true,\n    configurable: true\n  }); /// <summary>\n  /// Maximum count of bits.\n  /// </summary>\n\n  DecompressorHuffmanTree.MAX_BITLEN = 15;\n  return DecompressorHuffmanTree;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n/// <summary>\n/// Checksum calculator, based on Adler32 algorithm.\n/// </summary>\n\n\nvar ChecksumCalculator$1 =\n/** @__PURE__ @class */\nfunction () {\n  function ChecksumCalculator() {} /// <summary>\n  /// Updates checksum by calculating checksum of the\n  /// given buffer and adding it to current value.\n  /// </summary>\n  /// <param name=\"checksum\">Current checksum.</param>\n  /// <param name=\"buffer\">Data byte array.</param>\n  /// <param name=\"offset\">Offset in the buffer.</param>\n  /// <param name=\"length\">Length of data to be used from the stream.</param>\n\n\n  ChecksumCalculator.ChecksumUpdate = function (checksum, buffer, offset, length) {\n    var checkSumUInt = checksum;\n    var s1 = checkSumUInt & 65535;\n    var s2 = checkSumUInt >> this.DEF_CHECKSUM_BIT_OFFSET;\n\n    while (length > 0) {\n      var steps = Math.min(length, this.DEF_CHECKSUM_ITERATIONSCOUNT);\n      length -= steps;\n\n      while (--steps >= 0) {\n        s1 = s1 + (buffer[offset++] & 255);\n        s2 = s2 + s1;\n      }\n\n      s1 %= this.DEF_CHECKSUM_BASE;\n      s2 %= this.DEF_CHECKSUM_BASE;\n    }\n\n    checkSumUInt = s2 << this.DEF_CHECKSUM_BIT_OFFSET | s1;\n    checksum = checkSumUInt;\n  }; /// <summary>\n  /// Generates checksum by calculating checksum of the\n  /// given buffer.\n  /// </summary>\n  /// <param name=\"buffer\">Data byte array.</param>\n  /// <param name=\"offset\">Offset in the buffer.</param>\n  /// <param name=\"length\">Length of data to be used from the stream.</param>\n\n\n  ChecksumCalculator.ChecksumGenerate = function (buffer, offset, length) {\n    var result = 1;\n    ChecksumCalculator.ChecksumUpdate(result, buffer, offset, length);\n    return result;\n  }; /// <summary>\n  /// Bits offset, used in adler checksum calculation.\n  /// </summary>\n\n\n  ChecksumCalculator.DEF_CHECKSUM_BIT_OFFSET = 16; /// <summary>\n  /// Lagrest prime, less than 65535\n  /// </summary>\n\n  ChecksumCalculator.DEF_CHECKSUM_BASE = 65521; /// <summary>\n  /// Count of iteration used in calculated of the adler checksumm.\n  /// </summary>\n\n  ChecksumCalculator.DEF_CHECKSUM_ITERATIONSCOUNT = 3800;\n  return ChecksumCalculator;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n\n\nvar CompressedStreamReader =\n/** @__PURE__ @class */\nfunction () {\n  function CompressedStreamReader(stream, bNoWrap) {\n    /// <summary>\n    /// Code lengths for the code length alphabet.\n    /// </summary>\n    this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; /// <summary>\n    /// Mask for compression method to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_METHOD_MASK = 15 << 8; /// <summary>\n    /// Mask for compression info to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_INFO_MASK = 240 << 8; /// <summary>\n    /// Mask for check bits to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_FLAGS_FCHECK = 31; /// <summary>\n    /// Mask for dictionary presence to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_FLAGS_FDICT = 32; /// <summary>\n    /// Mask for compression level to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_FLAGS_FLEVEL = 192; /// <summary>\n    /// Maximum size of the data window.\n    /// </summary>\n\n    this.DEF_MAX_WINDOW_SIZE = 65535; /// <summary>\n    /// Maximum length of the repeatable block.\n    /// </summary>\n\n    this.DEF_HUFFMAN_REPEATE_MAX = 258; /// <summary>\n    /// End of the block sign.\n    /// </summary>\n\n    this.DEF_HUFFMAN_END_BLOCK = 256; /// <summary>\n    /// Minimal length code.\n    /// </summary>\n\n    this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257; /// <summary>\n    /// Maximal length code.\n    /// </summary>\n\n    this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285; /// <summary>\n    /// Maximal distance code.\n    /// </summary>\n\n    this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29; /// <summary>\n    /// Currently calculated checksum,\n    /// based on Adler32 algorithm.\n    /// </summary>\n\n    this.mCheckSum = 1; /// <summary>\n    /// Currently read 4 bytes.\n    /// </summary>\n\n    this.tBuffer = 0; /// <summary>\n    /// Count of bits that are in buffer.\n    /// </summary>\n\n    this.mBufferedBits = 0; /// <summary>\n    /// Temporary buffer.\n    /// </summary>\n\n    this.mTempBuffer = new Uint8Array(4); /// <summary>\n    /// 32k buffer for unpacked data.\n    /// </summary>\n\n    this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE); /// <summary>\n    /// No wrap mode.\n    /// </summary>\n\n    this.mbNoWrap = false; /// <summary>\n    /// Window size, can not be larger than 32k.\n    /// </summary>\n\n    this.mWindowSize = 0; /// <summary>\n    /// Current position in output stream.\n    /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n    /// </summary>\n\n    this.mCurrentPosition = 0; /// <summary>\n    /// Data length.\n    /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n    /// </summary>\n\n    this.mDataLength = 0; /// <summary>\n    /// Specifies wheather next block can to be read.\n    /// Reading can be denied because the header of the last block have been read.\n    /// </summary>\n\n    this.mbCanReadNextBlock = true; /// <summary>\n    /// Specifies wheather user can read more data from stream.\n    /// </summary>\n\n    this.mbCanReadMoreData = true; /// <summary>\n    /// Specifies wheather checksum has been read.\n    /// </summary>\n\n    this.mbCheckSumRead = false;\n\n    if (stream == null) {\n      throw new DOMException('stream');\n    }\n\n    if (stream.length === 0) {\n      throw new DOMException('stream - string can not be empty');\n    }\n\n    DecompressorHuffmanTree.init();\n    this.mInputStream = new Stream(stream);\n    this.mbNoWrap = bNoWrap;\n\n    if (!this.mbNoWrap) {\n      this.readZLibHeader();\n    }\n\n    this.decodeBlockHeader();\n  }\n\n  Object.defineProperty(CompressedStreamReader.prototype, \"mBuffer\", {\n    get: function () {\n      return this.tBuffer;\n    },\n    set: function (value) {\n      this.tBuffer = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  /// <summary>\n  /// Reads specified count of bits without adjusting position.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be read.</param>\n  /// <returns>Read value.</returns>\n\n  CompressedStreamReader.prototype.peekBits = function (count) {\n    if (count < 0) {\n      throw new DOMException('count', 'Bits count can not be less than zero.');\n    }\n\n    if (count > 32) {\n      throw new DOMException('count', 'Count of bits is too large.');\n    } // If buffered data is not enough to give result,\n    // fill buffer.\n\n\n    if (this.mBufferedBits < count) {\n      this.fillBuffer();\n    } // If you want to read 4 bytes and there is partial data in\n    // buffer, than you will fail.\n\n\n    if (this.mBufferedBits < count) {\n      return -1;\n    } // Create bitmask for reading of count bits\n\n\n    var bitMask = ~(4294967295 << count);\n    var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask); //Debug.WriteLine( /*new string( ' ', 32 - mBufferedBits + (int)( ( 32 - mBufferedBits ) / 8 ) ) + BitsToString( (int)mBuffer, mBufferedBits ) + \" \" + BitsToString( result, count ) +*/ \" \" + result.ToString() );\n\n    return result;\n  };\n\n  CompressedStreamReader.prototype.fillBuffer = function () {\n    var length = 4 - (this.mBufferedBits >> 3) - ((this.mBufferedBits & 7) !== 0 ? 1 : 0);\n\n    if (length === 0) {\n      return;\n    } //TODO: fix this\n\n\n    var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);\n\n    for (var i = 0; i < bytesRead; i++) {\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer | Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits));\n      this.mBufferedBits += 8;\n    } //TODO: fix this\n\n  }; /// <summary>\n  /// Skips specified count of bits.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be skipped.</param>\n\n\n  CompressedStreamReader.prototype.skipBits = function (count) {\n    if (count < 0) {\n      throw new DOMException('count', 'Bits count can not be less than zero.');\n    }\n\n    if (count === 0) {\n      return;\n    }\n\n    if (count >= this.mBufferedBits) {\n      count -= this.mBufferedBits;\n      this.mBufferedBits = 0;\n      this.mBuffer = 0; // if something left, skip it.\n\n      if (count > 0) {\n        // Skip entire bytes.\n        this.mInputStream.position += count >> 3; //TODO: fix this\n\n        count &= 7; // Skip bits.\n\n        if (count > 0) {\n          this.fillBuffer();\n          this.mBufferedBits -= count;\n          this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        }\n      }\n    } else {\n      this.mBufferedBits -= count;\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n    }\n  };\n\n  Object.defineProperty(CompressedStreamReader.prototype, \"availableBits\", {\n    get: function () {\n      return this.mBufferedBits;\n    },\n    enumerable: true,\n    configurable: true\n  }); /// <summary>\n  /// Reads ZLib header with compression method and flags.\n  /// </summary>\n\n  CompressedStreamReader.prototype.readZLibHeader = function () {\n    // first 8 bits - compression Method and flags\n    // 8 other - flags\n    var header = this.readInt16(); //Debug.WriteLine( BitsToString( header ) );\n\n    if (header === -1) {\n      throw new DOMException('Header of the stream can not be read.');\n    }\n\n    if (header % 31 !== 0) {\n      throw new DOMException('Header checksum illegal');\n    }\n\n    if ((header & this.DEF_HEADER_METHOD_MASK) !== 8 << 8) {\n      throw new DOMException('Unsupported compression method.');\n    }\n\n    this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);\n\n    if (this.mWindowSize > 65535) {\n      throw new DOMException('Unsupported window size for deflate compression method.');\n    }\n\n    if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {\n      // Get dictionary.\n      throw new DOMException('Custom dictionary is not supported at the moment.');\n    }\n  }; /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n\n\n  CompressedStreamReader.prototype.readInt16 = function () {\n    var result = this.readBits(8) << 8;\n    result |= this.readBits(8);\n    return result;\n  }; /// <summary>\n  /// Reads specified count of bits from stream.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be read.</param>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n\n\n  CompressedStreamReader.prototype.readBits = function (count) {\n    var result = this.peekBits(count);\n\n    if (result === -1) {\n      return -1;\n    }\n\n    this.mBufferedBits -= count;\n    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n    return result;\n  }; /// <summary>\n  /// Reads and decodes block of data.\n  /// </summary>\n  /// <returns>True if buffer was empty and new data was read, otherwise - False.</returns>\n\n\n  CompressedStreamReader.prototype.decodeBlockHeader = function () {\n    if (!this.mbCanReadNextBlock) {\n      return false;\n    }\n\n    var bFinalBlock = this.readBits(1);\n\n    if (bFinalBlock === -1) {\n      return false;\n    }\n\n    var blockType = this.readBits(2);\n\n    if (blockType === -1) {\n      return false;\n    }\n\n    this.mbCanReadNextBlock = bFinalBlock === 0; //      ChecksumReset();\n\n    switch (blockType) {\n      case 0:\n        // Uncompressed data\n        this.mbReadingUncompressed = true;\n        this.skipToBoundary();\n        var length_1 = this.readInt16Inverted();\n        var lengthComplement = this.readInt16Inverted();\n\n        if (length_1 !== (lengthComplement ^ 0xffff)) {\n          throw new DOMException('Wrong block length.');\n        }\n\n        if (length_1 > 65535) {\n          throw new DOMException('Uncompressed block length can not be more than 65535.');\n        }\n\n        this.mUncompressedDataLength = length_1;\n        this.mCurrentLengthTree = null;\n        this.mCurrentDistanceTree = null;\n        break;\n\n      case 1:\n        // Compressed data with fixed huffman codes.\n        this.mbReadingUncompressed = false;\n        this.mUncompressedDataLength = -1;\n        this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;\n        this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;\n        break;\n\n      case 2:\n        // Compressed data with dynamic huffman codes.\n        this.mbReadingUncompressed = false;\n        this.mUncompressedDataLength = -1;\n        var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);\n        this.mCurrentLengthTree = trees.lengthTree;\n        this.mCurrentDistanceTree = trees.distanceTree;\n        break;\n\n      default:\n        throw new DOMException('Wrong block type.');\n    }\n\n    return true;\n  }; /// <summary>\n  /// Discards left-most partially used byte.\n  /// </summary>\n\n\n  CompressedStreamReader.prototype.skipToBoundary = function () {\n    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));\n    this.mBufferedBits &= ~7;\n  }; /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n\n\n  CompressedStreamReader.prototype.readInt16Inverted = function () {\n    var result = this.readBits(8);\n    result |= this.readBits(8) << 8;\n    return result;\n  }; /// <summary>\n  /// Reades dynamic huffman codes from block header.\n  /// </summary>\n  /// <param name=\"lengthTree\">Literals/Lengths tree.</param>\n  /// <param name=\"distanceTree\">Distances tree.</param>\n\n\n  CompressedStreamReader.prototype.decodeDynamicHeader = function (lengthTree, distanceTree) {\n    var bLastSymbol = 0;\n    var iLengthsCount = this.readBits(5);\n    var iDistancesCount = this.readBits(5);\n    var iCodeLengthsCount = this.readBits(4);\n\n    if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {\n      throw new DOMException('Wrong dynamic huffman codes.');\n    }\n\n    iLengthsCount += 257;\n    iDistancesCount += 1;\n    var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;\n    var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);\n    var arrDecoderCodeLengths = new Uint8Array(19);\n    iCodeLengthsCount += 4;\n    var iCurrentCode = 0;\n\n    while (iCurrentCode < iCodeLengthsCount) {\n      var len = this.readBits(3);\n\n      if (len < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;\n    }\n\n    var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);\n    iCurrentCode = 0;\n\n    for (;;) {\n      var symbol = void 0;\n      var bNeedBreak = false;\n      symbol = treeInternalDecoder.unpackSymbol(this);\n\n      while ((symbol & ~15) === 0) {\n        arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;\n\n        if (iCurrentCode === iResultingCodeLengthsCount) {\n          bNeedBreak = true;\n          break;\n        }\n\n        symbol = treeInternalDecoder.unpackSymbol(this);\n      }\n\n      if (bNeedBreak) {\n        break;\n      }\n\n      if (symbol < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      if (symbol >= 17) {\n        bLastSymbol = 0;\n      } else if (iCurrentCode === 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      var miRepSymbol = symbol - 16;\n      var bits = CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];\n      var count = this.readBits(bits);\n\n      if (count < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      count += CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];\n\n      if (iCurrentCode + count > iResultingCodeLengthsCount) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      while (count-- > 0) {\n        arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;\n      }\n\n      if (iCurrentCode === iResultingCodeLengthsCount) {\n        break;\n      }\n    }\n\n    var tempArray = new Uint8Array(iLengthsCount);\n    tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0); //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n    //Array.copy( arrResultingCodeLengths, 0, tempArray, 0, iLengthsCount );\n\n    lengthTree = new DecompressorHuffmanTree(tempArray);\n    tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount); //Array.copy( arrResultingCodeLengths, iLengthsCount, tempArray, 0, iDistancesCount );\n\n    distanceTree = new DecompressorHuffmanTree(tempArray);\n    return {\n      'lengthTree': lengthTree,\n      'distanceTree': distanceTree\n    };\n  }; /// <summary>\n  /// Decodes huffman codes.\n  /// </summary>\n  /// <returns>True if some data was read.</returns>\n\n\n  CompressedStreamReader.prototype.readHuffman = function () {\n    var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);\n    var dataRead = false; //long maxdistance = DEF_MAX_WINDOW_SIZE >> 1;\n\n    var readdata = {}; // DEF_HUFFMAN_REPEATE_MAX - longest repeatable block, we should always reserve space for it because\n    // if we should not, we will have buffer overrun.\n\n    while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {\n      var symbol = void 0;\n      symbol = this.mCurrentLengthTree.unpackSymbol(this); // Only codes 0..255 are valid independent symbols.\n\n      while ((symbol & ~0xff) === 0) {\n        readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;\n        this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;\n        dataRead = true;\n\n        if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {\n          return true;\n        } //if( (mDataLength - mCurrentPosition ) < maxdistance ) return true;\n\n\n        symbol = this.mCurrentLengthTree.unpackSymbol(this);\n      }\n\n      if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {\n        if (symbol < this.DEF_HUFFMAN_END_BLOCK) {\n          throw new DOMException('Illegal code.');\n        }\n\n        var numDataRead = dataRead ? 1 : 0;\n        this.mbCanReadMoreData = this.decodeBlockHeader();\n        var numReadMore = this.mbCanReadMoreData ? 1 : 0;\n        return numDataRead | numReadMore ? true : false;\n      }\n\n      if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {\n        throw new DOMException('Illegal repeat code length.');\n      }\n\n      var iRepeatLength = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n      var iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n\n      if (iRepeatExtraBits > 0) {\n        var extra = this.readBits(iRepeatExtraBits);\n\n        if (extra < 0) {\n          throw new DOMException('Wrong data.');\n        }\n\n        iRepeatLength += extra;\n      } // Unpack repeat distance.\n\n\n      symbol = this.mCurrentDistanceTree.unpackSymbol(this);\n\n      if (symbol < 0 || symbol > CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {\n        throw new DOMException('Wrong distance code.');\n      }\n\n      var iRepeatDistance = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];\n      iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];\n\n      if (iRepeatExtraBits > 0) {\n        var extra = this.readBits(iRepeatExtraBits);\n\n        if (extra < 0) {\n          throw new DOMException('Wrong data.');\n        }\n\n        iRepeatDistance += extra;\n      } // Copy data in slow repeat mode\n\n\n      for (var i = 0; i < iRepeatLength; i++) {\n        this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] = this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];\n        this.mDataLength++;\n        free--;\n      }\n\n      dataRead = true;\n    }\n\n    return dataRead;\n  }; /// <summary>\n  /// Reads data to buffer.\n  /// </summary>\n  /// <param name=\"buffer\">Output buffer for data.</param>\n  /// <param name=\"offset\">Offset in output data.</param>\n  /// <param name=\"length\">Length of the data to be read.</param>\n  /// <returns>Count of bytes actually read.</returns>\n\n\n  CompressedStreamReader.prototype.read = function (buffer, offset, length) {\n    if (buffer == null) {\n      throw new DOMException('buffer');\n    }\n\n    if (offset < 0 || offset > buffer.length - 1) {\n      throw new DOMException('offset', 'Offset does not belong to specified buffer.');\n    }\n\n    if (length < 0 || length > buffer.length - offset) {\n      throw new DOMException('length', 'Length is illegal.');\n    }\n\n    var initialLength = length;\n\n    while (length > 0) {\n      // Read from internal buffer.\n      if (this.mCurrentPosition < this.mDataLength) {\n        // Position in buffer array.\n        var inBlockPosition = this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE; // We can not read more than we have in buffer at once,\n        // and we not read more than till the array end.\n\n        var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, this.mDataLength - this.mCurrentPosition); // Reading not more, than the rest of the buffer.\n\n        dataToCopy = Math.min(dataToCopy, length); //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n        // Copy data.\n        //Array.Copy( mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy );\n        //buffer.set(this.mBlockBuffer.slice(inBlockPosition, dataToCopy), offset);\n\n        Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy); // Correct position, length,\n\n        this.mCurrentPosition += dataToCopy;\n        offset += dataToCopy;\n        length -= dataToCopy;\n      } else {\n        if (!this.mbCanReadMoreData) {\n          break;\n        }\n\n        var oldDataLength = this.mDataLength;\n\n        if (!this.mbReadingUncompressed) {\n          if (!this.readHuffman()) {\n            break;\n          }\n        } else {\n          if (this.mUncompressedDataLength === 0) {\n            // If there is no more data in stream, just exit.\n            this.mbCanReadMoreData = this.decodeBlockHeader();\n\n            if (!this.mbCanReadMoreData) {\n              break;\n            }\n          } else {\n            // Position of the data end in block buffer.\n            var inBlockPosition = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;\n            var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);\n            var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);\n\n            if (dataToRead !== dataRead) {\n              throw new DOMException('Not enough data in stream.');\n            }\n\n            this.mUncompressedDataLength -= dataRead;\n            this.mDataLength += dataRead;\n          }\n        }\n\n        if (oldDataLength < this.mDataLength) {\n          var start = oldDataLength % this.DEF_MAX_WINDOW_SIZE;\n          var end = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;\n\n          if (start < end) {\n            this.checksumUpdate(this.mBlockBuffer, start, end - start);\n          } else {\n            this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);\n\n            if (end > 0) {\n              this.checksumUpdate(this.mBlockBuffer, 0, end);\n            }\n          }\n        }\n      }\n    }\n\n    if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {\n      this.skipToBoundary();\n      var checkSum = this.readInt32(); //Debug.Assert( checkSum == mCheckSum, \"\" );\n\n      if (checkSum !== this.mCheckSum) {\n        throw new DOMException('Checksum check failed.');\n      }\n\n      this.mbCheckSumRead = true;\n    }\n\n    return initialLength - length;\n  }; /// <summary>\n  /// Reads array of bytes.\n  /// </summary>\n  /// <param name=\"buffer\">Output buffer.</param>\n  /// <param name=\"offset\">Offset in output buffer.</param>\n  /// <param name=\"length\">Length of the data to be read.</param>\n  /// <returns>Count of bytes actually read to the buffer.</returns>\n\n\n  CompressedStreamReader.prototype.readPackedBytes = function (buffer, offset, length) {\n    if (buffer == null) {\n      throw new DOMException('buffer');\n    }\n\n    if (offset < 0 || offset > buffer.length - 1) {\n      throw new DOMException('offset\", \"Offset can not be less than zero or greater than buffer length - 1.');\n    }\n\n    if (length < 0) {\n      throw new DOMException('length\", \"Length can not be less than zero.');\n    }\n\n    if (length > buffer.length - offset) {\n      throw new DOMException('length\", \"Length is too large.');\n    }\n\n    if ((this.mBufferedBits & 7) !== 0) {\n      throw new DOMException('Reading of unalligned data is not supported.');\n    }\n\n    if (length === 0) {\n      return 0;\n    }\n\n    var result = 0;\n\n    while (this.mBufferedBits > 0 && length > 0) {\n      buffer[offset++] = this.mBuffer;\n      this.mBufferedBits -= 8;\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);\n      length--;\n      result++;\n    }\n\n    if (length > 0) {\n      //TODO: Fix this.\n      result += this.mInputStream.read(buffer, offset, length);\n    }\n\n    return result;\n  }; /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n\n\n  CompressedStreamReader.prototype.readInt32 = function () {\n    var result = this.readBits(8) << 24;\n    result |= this.readBits(8) << 16;\n    result |= this.readBits(8) << 8;\n    result |= this.readBits(8);\n    return result;\n  }; /// <summary>\n  /// Updates checksum by calculating checksum of the\n  /// given buffer and adding it to current value.\n  /// </summary>\n  /// <param name=\"buffer\">Data byte array.</param>\n  /// <param name=\"offset\">Offset in the buffer.</param>\n  /// <param name=\"length\">Length of data to be used from the stream.</param>\n\n\n  CompressedStreamReader.prototype.checksumUpdate = function (buffer, offset, length) {\n    ChecksumCalculator$1.ChecksumUpdate(this.mCheckSum, buffer, offset, length);\n  };\n\n  CompressedStreamReader.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]); /// <summary>\n  /// Minimum count of repetions.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11]; /// <summary>\n  /// Bits, that responds for different repetion modes.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7]; /// <summary>\n  /// Length bases.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]; /// <summary>\n  /// Length extended bits count.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]; /// <summary>\n  /// Distance bases.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]; /// <summary>\n  /// Distance extanded bits count.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n  return CompressedStreamReader;\n}();\n\nvar Stream =\n/** @__PURE__ @class */\nfunction () {\n  function Stream(input) {\n    this.position = 0;\n    this.inputStream = new Uint8Array(input.buffer);\n  }\n\n  Object.defineProperty(Stream.prototype, \"length\", {\n    get: function () {\n      return this.inputStream.buffer.byteLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Stream.prototype.read = function (buffer, start, length) {\n    var temp = new Uint8Array(this.inputStream.buffer, this.position + start);\n    var data = temp.subarray(0, length);\n    buffer.set(data, 0);\n    this.position += data.byteLength;\n    return data.byteLength;\n  };\n\n  Stream.prototype.readByte = function () {\n    return this.inputStream[this.position++];\n  };\n\n  Stream.prototype.write = function (inputBuffer, offset, count) {\n    Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count); // this.inputStream = new Uint8Array(this.inputStream.buffer, this.position + offset);\n    // this.inputStream.set(inputBuffer, offset);\n\n    this.position += count;\n  };\n\n  Stream.prototype.toByteArray = function () {\n    return new Uint8Array(this.inputStream.buffer);\n  };\n\n  return Stream;\n}();\n/* eslint-enable */\n\n/**\n * export ZipArchive class\n */\n\n\nexport { ZipArchive, ZipArchiveItemHelper, ZipArchiveItem, CompressedStreamWriter, CompressorHuffmanTree, ChecksumCalculator, Utils, DecompressorHuffmanTree, CompressedStreamReader, Stream };","map":{"version":3,"names":["Encoding","Save","Utils","bitReverse","value","reverseBits","bitConverterToInt32","index","bitConverterToInt16","bitConverterToUInt32","uint","Uint32Array","bitConverterToUInt16","Uint16Array","bitConverterUintToInt32","Int32Array","bitConverterInt32ToUint","bitConverterInt32ToInt16","Int16Array","byteToString","str","i","length","String","fromCharCode","byteIntToString","arrayCopy","source","sourceIndex","destination","destinationIndex","dataToCopy","temp","Uint8Array","buffer","data","subarray","set","mergeArray","arrayOne","arrayTwo","mergedArray","encodedString","input","keyStr","chr1","chr2","chr3","encode1","encode2","encode3","encode4","count","resultIndex","replace","totalLength","charAt","Error","output","indexOf","huffCodeLengthOrders","CRC32TABLE","INT_SIZE","SHORT_SIZE","CentralDirectoryEndSignature","CentralDirSizeOffset","CentralHeaderSignature","BufferSize","ZipArchive","initCrc32Table","files","level","isMicrosoftBrowser","navigator","msSaveBlob","Object","defineProperty","prototype","get","enumerable","configurable","undefined","addItem","item","file","ZipArchiveItem","name","push","addDirectory","directoryName","slice","getItem","contains","open","base64String","zipByteArray","DOMException","stream","Stream","lCentralDirEndPosition","findValueFromEnd","position","iCentralDirSize","ReadInt32","lCentralDirPosition","readCentralDirectoryDataAndExtractItems","itemHelper","ZipArchiveItemHelper","readCentralDirectoryData","readData","checkCrc","decompressData","unCompressedStream","save","fileName","zipArchive","promise","Promise","resolve","reject","saveInternal","then","saveAsBlob","blob","skipFileSave","_this","zipData","dirLength","compressedObject","getCompressedData","constructZippedObject","isDirectory","writeZippedContent","destroy","reader_1","FileReader","onload","result","crc32Value","compressedData","compressedSize","uncompressedDataSize","compressionType","compressData","length_1","calculateCrc32Value","readAsArrayBuffer","crc32Table","compressor","CompressedStreamWriter","currentIndex","nextIndex","close","Math","min","subArray","write","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getBytes","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","getArrayBuffer","shift","writeFooter","Blob","type","offset","externalFileAttribute","directoryHeader","centralLength","localLength","dirEnd","a","j","charCodeAt","bytes","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","k","maxCount","lStreamSize","inputStream","byteLength","arrBuffer","lLastPos","max","lCurrentPosition","read","uiCurValue","bFound","readByte","ReadInt16","ReadUInt16","headerSignature","crc32","options","compressionMethod","lastModified","originalSize","iFileNameLength","iExtraFieldLenth","iCommentLength","externalAttributes","localHeaderOffset","m_strItemName","readLocalHeader","readCompressedData","decompressDataOld","reader","CompressedStreamReader","compressedStream","decompressedData","iReadBytes","toByteArray","iNameLength","iExtraLength","headerVal","dataStream","iBytesLeft","iBytesToRead","itemName","decompressedStream","ARR_LITERAL_CODES","ARR_LITERAL_LENGTHS","ARR_DISTANCE_CODES","ARR_DISTANCE_LENGTHS","noWrap","pendingBuffer","pendingBufLength","pendingBufCache","pendingBufBitsInCache","bufferPosition","extraBits","currentHash","matchStart","matchLength","matchPrevAvail","blockStart","stringStart","lookAhead","totalBytesIn","inputOffset","inputEnd","windowSize","windowMask","hashSize","hashMask","hashShift","floor","maxDist","checkSum","isHuffmanTreeInitiated","initHuffmanTree","treeLiteral","CompressorHuffmanTree","treeDistances","treeCodeLengths","arrDistances","arrLiterals","dataWindow","hashHead","hashPrevious","writeZLibHeader","compressedString","apply","end","encode","inputBuffer","ChecksumCalculator","checksumUpdate","pendingBufferFlush","headerDate","pendingBufferWriteShortBytes","s","finish","success","fillWindow","canFlush","compressSlow","flush","lookAheadCompleted","slideWindow","prevMatch","prevLen","discardMatch","matchPreviousBest","matchPreviousAvailable","huffmanIsFull","insertString","findLongestMatch","huffmanTallyLit","huffmanTallyDist","huffmanFlushBlock","len","lastBlock","more","updateHash","m","match","hash","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","limit","stringEnd","scanEnd1","scanEnd","literal","codeFrequencies","dist","lc","huffmanLengthCode","dc","huffmanDistanceCode","stored","storedOffset","storedLength","buildTree","calculateBLFreq","blTreeCodes","codeLengths","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanCompressBlock","huffmanReset","huffmanSendAllTrees","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","literalLen","writeCodeToStream","bits","b","pendingBufferFlushBits","isClose","array","writer","elementCount","minCodes","maxLength","codeMinCount","codeFrequency","lengthCount","codeCount","codeLength","codes","lengths","lengthTemp","nextCode","bitsCount","blTree","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentRepeatCount","currentCodeLength","codesCount","arrTree","n","freq","pos","pPos","leafsCount","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","childIndex","bitLength","checksum","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase","DecompressorHuffmanTree","init","m_LengthTree","m_DistanceTree","prepareData","blCount","treeSize","MAX_BITLEN","start","treeFromData","tree","pointer","increment","revcode","subTree","treeLen","m_Tree","unpackSymbol","lookahead","symbol","peekBits","skipBits","subtree","bitlen","availableBits","ChecksumCalculator$1","ChecksumUpdate","checkSumUInt","DEF_CHECKSUM_BIT_OFFSET","DEF_CHECKSUM_ITERATIONSCOUNT","DEF_CHECKSUM_BASE","ChecksumGenerate","bNoWrap","defaultHuffmanDynamicTree","DEF_HEADER_METHOD_MASK","DEF_HEADER_INFO_MASK","DEF_HEADER_FLAGS_FCHECK","DEF_HEADER_FLAGS_FDICT","DEF_HEADER_FLAGS_FLEVEL","DEF_MAX_WINDOW_SIZE","DEF_HUFFMAN_REPEATE_MAX","DEF_HUFFMAN_END_BLOCK","DEF_HUFFMAN_LENGTH_MINIMUMCODE","DEF_HUFFMAN_LENGTH_MAXIMUMCODE","DEF_HUFFMAN_DISTANCE_MAXIMUMCODE","mCheckSum","tBuffer","mBufferedBits","mTempBuffer","mBlockBuffer","mbNoWrap","mWindowSize","mCurrentPosition","mDataLength","mbCanReadNextBlock","mbCanReadMoreData","mbCheckSumRead","mInputStream","readZLibHeader","decodeBlockHeader","fillBuffer","bitMask","mBuffer","bytesRead","readInt16","pow","readBits","bFinalBlock","blockType","mbReadingUncompressed","skipToBoundary","readInt16Inverted","lengthComplement","mUncompressedDataLength","mCurrentLengthTree","mCurrentDistanceTree","lengthTree","distanceTree","trees","decodeDynamicHeader","bLastSymbol","iLengthsCount","iDistancesCount","iCodeLengthsCount","iResultingCodeLengthsCount","arrResultingCodeLengths","arrDecoderCodeLengths","iCurrentCode","treeInternalDecoder","bNeedBreak","miRepSymbol","DEF_HUFFMAN_DYNTREE_REPEAT_BITS","DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS","tempArray","readHuffman","free","dataRead","readdata","numDataRead","numReadMore","iRepeatLength","DEF_HUFFMAN_REPEAT_LENGTH_BASE","iRepeatExtraBits","DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION","extra","DEF_HUFFMAN_REPEAT_DISTANCE_BASE","iRepeatDistance","DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION","initialLength","inBlockPosition","oldDataLength","dataToRead","readPackedBytes","readInt32","DEF_REVERSE_BITS"],"sources":["E:/Hims UI/node_modules/@syncfusion/ej2-compression/dist/es6/ej2-compression.es5.js"],"sourcesContent":["import { Encoding, Save } from '@syncfusion/ej2-file-utils';\n\n/* eslint-disable */\nvar Utils = /** @__PURE__ @class */ (function () {\n    function Utils() {\n    }\n    Utils.bitReverse = function (value) {\n        return (Utils.reverseBits[value & 15] << 12\n            | Utils.reverseBits[(value >> 4) & 15] << 8\n            | Utils.reverseBits[(value >> 8) & 15] << 4\n            | Utils.reverseBits[value >> 12]);\n    };\n    Utils.bitConverterToInt32 = function (value, index) {\n        return value[index] | value[index + 1] << 8 | value[index + 2] << 16 | value[index + 3] << 24;\n    };\n    Utils.bitConverterToInt16 = function (value, index) {\n        return value[index] | value[index + 1] << 8;\n    };\n    Utils.bitConverterToUInt32 = function (value) {\n        var uint = new Uint32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterToUInt16 = function (value, index) {\n        var uint = new Uint16Array(1);\n        uint[0] = (value[index] | value[index + 1] << 8);\n        return uint[0];\n    };\n    Utils.bitConverterUintToInt32 = function (value) {\n        var uint = new Int32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterInt32ToUint = function (value) {\n        var uint = new Uint32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterInt32ToInt16 = function (value) {\n        var uint = new Int16Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.byteToString = function (value) {\n        var str = '';\n        for (var i = 0; i < value.length; i++) {\n            str += String.fromCharCode(value[i]);\n        }\n        return str;\n    };\n    Utils.byteIntToString = function (value) {\n        var str = '';\n        for (var i = 0; i < value.length; i++) {\n            str += String.fromCharCode(value[i]);\n        }\n        return str;\n    };\n    Utils.arrayCopy = function (source, sourceIndex, destination, destinationIndex, dataToCopy) {\n        var temp = new Uint8Array(source.buffer, sourceIndex);\n        var data = temp.subarray(0, dataToCopy);\n        destination.set(data, destinationIndex);\n    };\n    Utils.mergeArray = function (arrayOne, arrayTwo) {\n        var mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n        mergedArray.set(arrayOne);\n        mergedArray.set(arrayTwo, arrayOne.length);\n        return mergedArray;\n    };\n    /**\n     * @private\n     */\n    Utils.encodedString = function (input) {\n        var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        var chr1;\n        var chr2;\n        var chr3;\n        var encode1;\n        var encode2;\n        var encode3;\n        var encode4;\n        var count = 0;\n        var resultIndex = 0;\n        /*let dataUrlPrefix: string = 'data:';*/\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n        var totalLength = input.length * 3 / 4;\n        if (input.charAt(input.length - 1) === keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (input.charAt(input.length - 2) === keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (totalLength % 1 !== 0) {\n            // totalLength is not an integer, the length does not match a valid\n            // base64 content. That can happen if:\n            // - the input is not a base64 content\n            // - the input is *almost* a base64 content, with a extra chars at the\n            // beginning or at the end\n            // - the input uses a base64 variant (base64url for example)\n            throw new Error('Invalid base64 input, bad content length.');\n        }\n        var output = new Uint8Array(totalLength | 0);\n        while (count < input.length) {\n            encode1 = keyStr.indexOf(input.charAt(count++));\n            encode2 = keyStr.indexOf(input.charAt(count++));\n            encode3 = keyStr.indexOf(input.charAt(count++));\n            encode4 = keyStr.indexOf(input.charAt(count++));\n            chr1 = (encode1 << 2) | (encode2 >> 4);\n            chr2 = ((encode2 & 15) << 4) | (encode3 >> 2);\n            chr3 = ((encode3 & 3) << 6) | encode4;\n            output[resultIndex++] = chr1;\n            if (encode3 !== 64) {\n                output[resultIndex++] = chr2;\n            }\n            if (encode4 !== 64) {\n                output[resultIndex++] = chr3;\n            }\n        }\n        return output;\n    };\n    Utils.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    Utils.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return Utils;\n}());\n\n/* eslint-enable */\n\n/* eslint-disable */\nvar CRC32TABLE = [];\n/// <summary>\n/// Size of the int value in bytes.\n/// </summary>\nvar INT_SIZE = 4;\n/// <summary>\n/// Size of the short value in bytes.\n/// </summary>\nvar SHORT_SIZE = 2;\n/// <summary>\n/// End of central directory signature.\n/// </summary>\nvar CentralDirectoryEndSignature = 0x06054b50;\n/// <summary>\n/// Offset to the size field in the End of central directory record.\n/// </summary>\nvar CentralDirSizeOffset = 12;\n/// <summary>\n/// Central header signature.\n/// </summary>\nvar CentralHeaderSignature = 0x02014b50;\n/// <summary>\n/// Buffer size.\n/// </summary>\nvar BufferSize = 4096;\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @__PURE__ @class */ (function () {\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    function ZipArchive() {\n        if (CRC32TABLE.length === 0) {\n            ZipArchive.initCrc32Table();\n        }\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(ZipArchive.prototype, \"items\", {\n        get: function () {\n            return this.files;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n        /**\n         * gets compression level\n         */\n        get: function () {\n            return this.level;\n        },\n        /**\n         * sets compression level\n         */\n        set: function (level) {\n            this.level = level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"length\", {\n        /**\n         * gets items count\n         */\n        get: function () {\n            if (this.files === undefined) {\n                return 0;\n            }\n            return this.files.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    ZipArchive.prototype.addItem = function (item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (var i = 0; i < this.files.length; i++) {\n            var file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    };\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    ZipArchive.prototype.addDirectory = function (directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    };\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    ZipArchive.prototype.getItem = function (index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    };\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    ZipArchive.prototype.contains = function (item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    };\n    ZipArchive.prototype.open = function (base64String) {\n        //return promise = new Promise((resolve: Function, reject: Function) => {\n        var zipByteArray = Utils.encodedString(base64String);\n        if (zipByteArray.length == 0)\n            throw new DOMException(\"stream\");\n        var stream = new Stream(zipByteArray);\n        //let lCentralDirEndPosition = this.findValueFromEnd( arrBuffer, Constants.CentralDirectoryEndSignature, 65557 );\n        var lCentralDirEndPosition = ZipArchive.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);\n        if (lCentralDirEndPosition < 0)\n            throw new DOMException(\"Can't locate end of central directory record. Possible wrong file format or archive is corrupt.\");\n        // Step2. Locate central directory and iterate through all items\n        stream.position = lCentralDirEndPosition + CentralDirSizeOffset;\n        var iCentralDirSize = ZipArchive.ReadInt32(stream);\n        var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize;\n        // verify that this is really central directory\n        stream.position = lCentralDirPosition;\n        this.readCentralDirectoryDataAndExtractItems(stream);\n        //});\n        // let zipArchive: ZipArchive = this;\n        //let promise: Promise<ZipArchive>;\n        // return promise = new Promise((resolve: Function, reject: Function) => {\n        //     let reader: FileReader = new FileReader();\n        //     reader.onload = (e: Event) => {\n        //         let data: Uint8Array = new Uint8Array((e.target as any).result);\n        //         let zipReader: ZipReader = new ZipReader(data);\n        //         zipReader.readEntries().then((entries: ZipEntry[]) => {\n        //             for (let i: number = 0; i < entries.length; i++) {\n        //                 let entry: ZipEntry = entries[i];\n        //                 let item: ZipArchiveItem = new ZipArchiveItem(zipArchive, entry.fileName);\n        //                 item.data = entry.data;\n        //                 item.compressionMethod = entry.compressionMethod;\n        //                 item.crc = entry.crc;\n        //                 item.lastModified = entry.lastModified;\n        //                 item.lastModifiedDate = entry.lastModifiedDate;\n        //                 item.size = entry.size;\n        //                 item.uncompressedSize = entry.uncompressedSize;\n        //                 zipArchive.addItem(item);\n        //             }\n        //             resolve(zipArchive);\n        //         });\n        //     };\n        //     reader.readAsArrayBuffer(fileName);\n        // });\n    };\n    /// <summary>\n    /// Read central directory record from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read from.</param>\n    ZipArchive.prototype.readCentralDirectoryDataAndExtractItems = function (stream) {\n        if (stream == null)\n            throw new DOMException(\"stream\");\n        var itemHelper;\n        while (ZipArchive.ReadInt32(stream) == CentralHeaderSignature) {\n            itemHelper = new ZipArchiveItemHelper();\n            itemHelper.readCentralDirectoryData(stream);\n            \n            // let item: ZipArchiveItem = new ZipArchiveItem(this);\n            // item.ReadCentralDirectoryData(stream);\n            // m_arrItems.Add(item);\n        }\n        itemHelper.readData(stream, itemHelper.checkCrc);\n        itemHelper.decompressData();\n        this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));\n    };\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    ZipArchive.prototype.save = function (fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal(fileName, false).then(function () {\n                resolve(zipArchive);\n            });\n        });\n    };\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    ZipArchive.prototype.saveAsBlob = function () {\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal('', true).then(function (blob) {\n                resolve(blob);\n            });\n        });\n    };\n    ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n        var _this = this;\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            var zipData = [];\n            var dirLength = 0;\n            for (var i = 0; i < zipArchive.files.length; i++) {\n                var compressedObject = _this.getCompressedData(_this.files[i]);\n                compressedObject.then(function (data) {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchive.prototype.destroy = function () {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (var i = 0; i < this.files.length; i++) {\n                var file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    };\n    ZipArchive.prototype.getCompressedData = function (item) {\n        var zipArchive = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (item instanceof ZipArchiveItem) {\n                var reader_1 = new FileReader();\n                reader_1.onload = function () {\n                    var input = new Uint8Array(reader_1.result);\n                    var data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, CRC32TABLE);\n                        var length_1 = 0;\n                        for (var i = 0; i < data.compressedData.length; i++) {\n                            length_1 += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length_1;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader_1.readAsArrayBuffer(item.data);\n            }\n            else {\n                var data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    };\n    ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n        var compressor = new CompressedStreamWriter(true);\n        var currentIndex = 0;\n        var nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            var subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    };\n    ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n        var extFileAttr = 0;\n        var date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        var header = this.writeHeader(data, date);\n        var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    };\n    ZipArchive.prototype.writeHeader = function (data, date) {\n        var zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    };\n    ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n        var cenDirLen = 0;\n        var buffer = [];\n        for (var i = 0; i < zipData.length; i++) {\n            var item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (var i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        var blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    };\n    ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n        var directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    };\n    ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n        var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    };\n    ZipArchive.prototype.getArrayBuffer = function (input) {\n        var a = new Uint8Array(input.length);\n        for (var j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    };\n    ZipArchive.prototype.getBytes = function (value, offset) {\n        var bytes = '';\n        for (var i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    };\n    ZipArchive.prototype.getModifiedTime = function (date) {\n        var modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    };\n    ZipArchive.prototype.getModifiedDate = function (date) {\n        var modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    };\n    ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (var i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    };\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n    ZipArchive.initCrc32Table = function () {\n        var i;\n        for (var j = 0; j < 256; j++) {\n            i = j;\n            for (var k = 0; k < 8; k++) {\n                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n            }\n            CRC32TABLE[j] = i;\n        }\n    };\n    ZipArchive.findValueFromEnd = function (stream, value, maxCount) {\n        if (stream == null)\n            throw new DOMException(\"stream\");\n        //   if( !stream.CanSeek || !stream.CanRead )\n        //     throw new ArgumentOutOfRangeException( \"We need to have seekable and readable stream.\" );\n        // read last 4 bytes and compare with required value\n        var lStreamSize = stream.inputStream.buffer.byteLength;\n        if (lStreamSize < 4)\n            return -1;\n        var arrBuffer = new Uint8Array(4);\n        var lLastPos = Math.max(0, lStreamSize - maxCount);\n        var lCurrentPosition = lStreamSize - 1 - INT_SIZE;\n        stream.position = lCurrentPosition;\n        stream.read(arrBuffer, 0, INT_SIZE);\n        var uiCurValue = arrBuffer[0];\n        var bFound = (uiCurValue == value);\n        if (!bFound) {\n            while (lCurrentPosition > lLastPos) {\n                // remove unnecessary byte and replace it with new value.\n                uiCurValue <<= 8;\n                lCurrentPosition--;\n                stream.position = lCurrentPosition;\n                uiCurValue += stream.readByte();\n                if (uiCurValue == value) {\n                    bFound = true;\n                    break;\n                }\n            }\n        }\n        return bFound ? lCurrentPosition : -1;\n    };\n    /// <summary>\n    /// Extracts Int32 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadInt32 = function (stream) {\n        var buffer = new Uint8Array(INT_SIZE);\n        if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {\n            throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n        }\n        return Utils.bitConverterToInt32(buffer, 0);\n    };\n    /// <summary>\n    /// Extracts Int16 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadInt16 = function (stream) {\n        var buffer = new Uint8Array(SHORT_SIZE);\n        if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n            throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n        }\n        return Utils.bitConverterToInt16(buffer, 0);\n    };\n    /// <summary>\n    /// Extracts unsigned Int16 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadUInt16 = function (stream) {\n        {\n            var buffer = new Uint8Array(SHORT_SIZE);\n            if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n                throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n            }\n            return Utils.bitConverterToInt16(buffer, 0);\n        }\n    };\n    return ZipArchive;\n}());\nvar ZipArchiveItemHelper = /** @__PURE__ @class */ (function () {\n    function ZipArchiveItemHelper() {\n        /// <summary>\n        /// Zip header signature.\n        /// </summary>\n        this.headerSignature = 0x04034b50;\n        /// <summary>\n        /// Indicates whether we should check Crc value when reading item's data. Check\n        /// is performed when user gets access to decompressed data for the first time.\n        /// </summary>\n        this.checkCrc = true;\n        /// <summary>\n        /// Crc.\n        /// </summary>\n        this.crc32 = 0;\n    }\n    /// <summary>\n    /// Read data from the stream based on the central directory.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from, stream.Position must point at just after correct file header.</param>\n    ZipArchiveItemHelper.prototype.readCentralDirectoryData = function (stream) {\n        // on the current moment we ignore \"version made by\" and \"version needed to extract\" fields.\n        stream.position += 4;\n        this.options = ZipArchive.ReadInt16(stream);\n        this.compressionMethod = ZipArchive.ReadInt16(stream);\n        this.checkCrc = (this.compressionMethod != 99); //COmpression.Defalte != SecurityConstants.AES\n        //m_bCompressed = true;\n        // on the current moment we ignore \"last mod file time\" and \"last mod file date\" fields.\n        var lastModified = ZipArchive.ReadInt32(stream);\n        //LastModified = ConvertToDateTime(lastModified);\n        this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));\n        this.compressedSize = ZipArchive.ReadInt32(stream);\n        this.originalSize = ZipArchive.ReadInt32(stream);\n        var iFileNameLength = ZipArchive.ReadInt16(stream);\n        var iExtraFieldLenth = ZipArchive.ReadInt16(stream);\n        var iCommentLength = ZipArchive.ReadInt16(stream);\n        // on the current moment we ignore and \"disk number start\" (2 bytes),\n        // \"internal file attributes\" (2 bytes).\n        stream.position += 4;\n        this.externalAttributes = ZipArchive.ReadInt32(stream);\n        this.localHeaderOffset = ZipArchive.ReadInt32(stream);\n        var arrBuffer = new Uint8Array(iFileNameLength);\n        stream.read(arrBuffer, 0, iFileNameLength);\n        var m_strItemName = Utils.byteToString(arrBuffer);\n        m_strItemName = m_strItemName.replace(\"\\\\\", \"/\");\n        this.name = m_strItemName;\n        stream.position += iExtraFieldLenth + iCommentLength;\n        if (this.options != 0)\n            this.options = 0;\n    };\n    /// <summary>\n    /// Reads zipped data from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <param name=\"checkCrc\">Indicates whether we should check crc value after data decompression.</param>\n    ZipArchiveItemHelper.prototype.readData = function (stream, checkCrc) {\n        if (stream.length == 0)\n            throw new DOMException(\"stream\");\n        stream.position = this.localHeaderOffset;\n        this.checkCrc = checkCrc;\n        this.readLocalHeader(stream);\n        this.readCompressedData(stream);\n    };\n    ZipArchiveItemHelper.prototype.decompressData = function () {\n        if (this.compressionMethod == 8) {\n            if (this.originalSize > 0) {\n                this.decompressDataOld();\n            }\n        }\n    };\n    ZipArchiveItemHelper.prototype.decompressDataOld = function () {\n        var reader = new CompressedStreamReader(this.compressedStream, true);\n        var decompressedData;\n        if (this.originalSize > 0)\n            decompressedData = new Stream(new Uint8Array(this.originalSize));\n        var arrBuffer = new Uint8Array(BufferSize);\n        var iReadBytes;\n        while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {\n            //             past = new Uint8Array(decompressedData.length);\n            // let currentBlock: Uint8Array = arrBuffer.subarray(0, iReadBytes);\n            decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);\n        }\n        this.unCompressedStream = decompressedData.toByteArray();\n        //   this.originalSize = decompressedData.Length;\n        //   m_bControlStream = true;\n        //   m_streamData = decompressedData;\n        //   decompressedData.SetLength( m_lOriginalSize );\n        //   decompressedData.Capacity = ( int )m_lOriginalSize;\n        if (this.checkCrc) {\n            //TODO: fix this\n            //CheckCrc(decompressedData.ToArray());\n        }\n        //m_streamData.Position = 0;\n    };\n    /// <summary>\n    /// Extracts local header from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    ZipArchiveItemHelper.prototype.readLocalHeader = function (stream) {\n        if (stream.length == 0)\n            throw new DOMException(\"stream\");\n        if (ZipArchive.ReadInt32(stream) != this.headerSignature)\n            throw new DOMException(\"Can't find local header signature - wrong file format or file is corrupt.\");\n        // TODO: it is good to verify data read from the central directory record,\n        // but on the current moment we simply skip it.\n        stream.position += 22;\n        var iNameLength = ZipArchive.ReadInt16(stream);\n        var iExtraLength = ZipArchive.ReadUInt16(stream);\n        if (this.compressionMethod == 99) //SecurityConstants.AES\n         {\n            // stream.Position += iNameLength + 8;\n            // m_archive.EncryptionAlgorithm = (EncryptionAlgorithm)stream.ReadByte();\n            // m_actualCompression = new byte[2];\n            // stream.Read(m_actualCompression, 0, 2);\n        }\n        else if (iExtraLength > 2) {\n            stream.position += iNameLength;\n            var headerVal = ZipArchive.ReadInt16(stream);\n            if (headerVal == 0x0017) //PKZipEncryptionHeader\n                throw new DOMException(\"UnSupported\");\n            else\n                stream.position += iExtraLength - 2;\n        }\n        else\n            stream.position += iNameLength + iExtraLength;\n    };\n    /// <summary>\n    /// Extracts compressed data from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    ZipArchiveItemHelper.prototype.readCompressedData = function (stream) {\n        var dataStream;\n        if (this.compressedSize > 0) {\n            var iBytesLeft = this.compressedSize;\n            dataStream = new Stream(new Uint8Array(iBytesLeft));\n            var arrBuffer = new Uint8Array(BufferSize);\n            while (iBytesLeft > 0) {\n                var iBytesToRead = Math.min(iBytesLeft, BufferSize);\n                if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead)\n                    throw new DOMException(\"End of file reached - wrong file format or file is corrupt.\");\n                dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);\n                iBytesLeft -= iBytesToRead;\n            }\n            // if(m_archive.Password != null)\n            // {\n            //     byte[] dataBuffer = new byte[dataStream.Length];\n            //     dataBuffer = dataStream.ToArray();\n            //     dataStream=new MemoryStream( Decrypt(dataBuffer));\n            // }\n            this.compressedStream = new Uint8Array(dataStream.inputStream);\n            // m_bControlStream = true;\n        }\n        else if (this.compressedSize < 0) //If compression size is negative, then read until the next header signature reached.\n         {\n            //   MemoryStream dataStream = new MemoryStream();\n            //   int bt = 0;\n            //   bool proceed=true;\n            //   while (proceed)\n            //   {\n            //       if ((bt = stream.ReadByte()) == Constants.HeaderSignatureStartByteValue)\n            //       {\n            //           stream.Position -= 1;\n            //           int headerSignature = ZipArchive.ReadInt32(stream);\n            //           if (headerSignature==Constants.CentralHeaderSignature || headerSignature==Constants.CentralHeaderSignature)\n            //           {\n            //               proceed = false;\n            //           }\n            //           stream.Position -= 3;\n            //       }\n            //       if (proceed)\n            //           dataStream.WriteByte((byte)bt);\n            //   }\n            //   m_streamData = dataStream;\n            //   m_lCompressedSize = m_streamData.Length;\n            //   m_bControlStream = true;\n        }\n        else if (this.compressedSize == 0) {\n            //  m_streamData = new MemoryStream();\n        }\n    };\n    return ZipArchiveItemHelper;\n}());\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @__PURE__ @class */ (function () {\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    function ZipArchiveItem(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    Object.defineProperty(ZipArchiveItem.prototype, \"dataStream\", {\n        get: function () {\n            return this.decompressedStream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n        /**\n         * Get the name of archive item\n         * @returns string\n         */\n        get: function () {\n            return this.fileName;\n        },\n        /**\n         * Set the name of archive item\n         * @param  {string} value\n         */\n        set: function (value) {\n            this.fileName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchiveItem.prototype.destroy = function () {\n        this.fileName = undefined;\n        this.data = undefined;\n    };\n    return ZipArchiveItem;\n}());\n\n/* eslint-enable */\n\n/* eslint-disable */\n/**\n * array literal codes\n */\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @__PURE__ @class */ (function () {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    function CompressedStreamWriter(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n            CompressedStreamWriter.initHuffmanTree();\n            CompressedStreamWriter.isHuffmanTreeInitiated = true;\n        }\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n        /**\n         * get compressed data\n         */\n        get: function () {\n            return this.stream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n        get: function () {\n            var compressedString = '';\n            if (this.stream !== undefined) {\n                for (var i = 0; i < this.stream.length; i++) {\n                    compressedString += String.fromCharCode.apply(null, this.stream[i]);\n                }\n            }\n            return compressedString;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.write = function (data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        var end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            var encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    };\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    CompressedStreamWriter.prototype.writeZLibHeader = function () {\n        /* Initialize header.*/\n        var headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    };\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    };\n    CompressedStreamWriter.prototype.compressData = function (finish) {\n        var success;\n        do {\n            this.fillWindow();\n            var canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    };\n    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            var prevMatch = this.matchStart;\n            var prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    };\n    CompressedStreamWriter.prototype.discardMatch = function () {\n        var hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    };\n    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    };\n    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    };\n    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    };\n    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n        var len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    };\n    CompressedStreamWriter.prototype.fillWindow = function () {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    };\n    CompressedStreamWriter.prototype.slideWindow = function () {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (var i = 0; i < this.hashSize; ++i) {\n            var m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (var i = 0; i < this.windowSize; i++) {\n            var m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    };\n    CompressedStreamWriter.prototype.insertString = function () {\n        var match;\n        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    };\n    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n        var chainLen = 4096;\n        var niceLen = 258;\n        var scan = this.stringStart;\n        var match;\n        var bestEnd = this.stringStart + this.matchLength;\n        var bestLength = Math.max(this.matchLength, 3 - 1);\n        var limit = Math.max(this.stringStart - this.maxDist, 0);\n        var stringEnd = this.stringStart + 258 - 1;\n        var scanEnd1 = this.dataWindow[bestEnd - 1];\n        var scanEnd = this.dataWindow[bestEnd];\n        var data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    };\n    CompressedStreamWriter.prototype.updateHash = function () {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    };\n    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        var lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        var dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        var blTreeCodes = 4;\n        for (var i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        var static_len = this.extraBits;\n        for (var i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n        }\n        for (var i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    };\n    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    };\n    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n        if (len === 255) {\n            return 285;\n        }\n        var code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    };\n    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n        var code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    };\n    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (var rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    };\n    CompressedStreamWriter.prototype.huffmanReset = function () {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    };\n    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n        for (var i = 0; i < this.bufferPosition; i++) {\n            var literalLen = this.arrLiterals[i] & 255;\n            var dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                var lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                var bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                var dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    };\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n        var uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            var array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n        var result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n        var array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    };\n    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    };\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n    CompressedStreamWriter.initHuffmanTree = function () {\n        var i = 0;\n        while (i < 144) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        while (i < 256) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n            ARR_LITERAL_LENGTHS[i++] = 9;\n        }\n        while (i < 280) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n            ARR_LITERAL_LENGTHS[i++] = 7;\n        }\n        while (i < 286) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        for (i = 0; i < 30; i++) {\n            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n            ARR_DISTANCE_LENGTHS[i] = 5;\n        }\n    };\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.close = function () {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.destroy = function () {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    };\n    CompressedStreamWriter.isHuffmanTreeInitiated = false;\n    return CompressedStreamWriter;\n}());\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @__PURE__ @class */ (function () {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n        get: function () {\n            return this.codeCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n        get: function () {\n            return this.codeLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n        get: function () {\n            return this.codeFrequency;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n        var temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        var lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    };\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.reset = function () {\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    };\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    };\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildCodes = function () {\n        var nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        var code = 0;\n        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (var i = 0; i < this.codeCount; i++) {\n            var bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    };\n    CompressorHuffmanTree.bitReverse = function (value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    };\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    CompressorHuffmanTree.prototype.getEncodedLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    };\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n        var maxCount;\n        var minCount;\n        var count;\n        var curLen = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    };\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n        var maxRepeatCount;\n        var minRepeatCount;\n        var currentRepeatCount;\n        var currentCodeLength = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    };\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildTree = function () {\n        var codesCount = this.codeFrequency.length;\n        var arrTree = new Int32Array(codesCount);\n        var treeLength = 0;\n        var maxCount = 0;\n        for (var n = 0; n < codesCount; n++) {\n            var freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                var pos = treeLength++;\n                var pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        var leafsCount = treeLength;\n        var nodesCount = leafsCount;\n        var child = new Int32Array(4 * treeLength - 2);\n        var values = new Int32Array(2 * treeLength - 1);\n        for (var i = 0; i < treeLength; i++) {\n            var node = arrTree[i];\n            var iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    };\n    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n        do {\n            var first = arrTree[0];\n            var last = arrTree[--treeLength];\n            var lastVal = values[last];\n            var pPos = 0;\n            var path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            var second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    };\n    CompressorHuffmanTree.prototype.buildLength = function (child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        var numNodes = Math.floor(child.length / 2);\n        var numLeafs = Math.floor((numNodes + 1) / 2);\n        var overflow = 0;\n        for (var i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        var iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    };\n    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        var nodePtr = 2 * numLeafs;\n        for (var bits = this.maxLength; bits !== 0; bits--) {\n            var n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                var childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    };\n    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n        var lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (var i = numNodes - 1; i >= 0; i--) {\n            var childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                var bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                var bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    };\n    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return CompressorHuffmanTree;\n}());\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @__PURE__ @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n        var uint = new Uint32Array(1);\n        uint[0] = checksum;\n        var checksum_uint = uint[0];\n        var s1 = uint[0] = checksum_uint & 65535;\n        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    };\n    ChecksumCalculator.checkSumBitOffset = 16;\n    ChecksumCalculator.checksumBase = 65521;\n    ChecksumCalculator.checksumIterationCount = 3800;\n    return ChecksumCalculator;\n}());\n\n/* eslint-enable */\n\n/* eslint-disable */\nvar DecompressorHuffmanTree = /** @__PURE__ @class */ (function () {\n    function DecompressorHuffmanTree(lengths) {\n        this.buildTree(lengths);\n    }\n    DecompressorHuffmanTree.init = function () {\n        var lengths;\n        var index;\n        // Generate huffman tree for lengths.\n        lengths = new Uint8Array(288);\n        index = 0;\n        while (index < 144) {\n            lengths[index++] = 8;\n        }\n        while (index < 256) {\n            lengths[index++] = 9;\n        }\n        while (index < 280) {\n            lengths[index++] = 7;\n        }\n        while (index < 288) {\n            lengths[index++] = 8;\n        }\n        DecompressorHuffmanTree.m_LengthTree = new DecompressorHuffmanTree(lengths);\n        // Generate huffman tree for distances.\n        lengths = new Uint8Array(32);\n        index = 0;\n        while (index < 32) {\n            lengths[index++] = 5;\n        }\n        DecompressorHuffmanTree.m_DistanceTree = new DecompressorHuffmanTree(lengths);\n    };\n    /// <summary>\n    /// Prepares data for generating huffman tree.\n    /// </summary>\n    /// <param name=\"blCount\">Array of counts of each code length.</param>\n    /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    /// <param name=\"treeSize\">Calculated tree size.</param>\n    /// <returns>Code.</returns>\n    DecompressorHuffmanTree.prototype.prepareData = function (blCount, nextCode, lengths) {\n        var code = 0;\n        var treeSize = 512;\n        // Count number of codes for each code length.\n        for (var i = 0; i < lengths.length; i++) {\n            var length_1 = lengths[i];\n            if (length_1 > 0) {\n                blCount[length_1]++;\n            }\n        }\n        for (var bits = 1; bits <= DecompressorHuffmanTree.MAX_BITLEN; bits++) {\n            nextCode[bits] = code;\n            code += blCount[bits] << (16 - bits);\n            if (bits >= 10) {\n                var start = nextCode[bits] & 0x1ff80;\n                var end = code & 0x1ff80;\n                treeSize += (end - start) >> (16 - bits);\n            }\n        }\n        /*      if( code != 65536 )\n          throw new ZipException( \"Code lengths don't add up properly.\" );*/\n        return { 'code': code, 'treeSize': treeSize };\n    };\n    /// <summary>\n    /// Generates huffman tree.\n    /// </summary>\n    /// <param name=\"blCount\">Array of counts of each code length.</param>\n    /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n    /// <param name=\"code\">Precalculated code.</param>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    /// <param name=\"treeSize\">Calculated size of the tree.</param>\n    /// <returns>Generated tree.</returns>\n    DecompressorHuffmanTree.prototype.treeFromData = function (blCount, nextCode, lengths, code, treeSize) {\n        var tree = new Int16Array(treeSize);\n        var pointer = 512;\n        var increment = 1 << 7;\n        for (var bits = DecompressorHuffmanTree.MAX_BITLEN; bits >= 10; bits--) {\n            var end = code & 0x1ff80;\n            code -= blCount[bits] << (16 - bits);\n            var start = code & 0x1ff80;\n            for (var i = start; i < end; i += increment) {\n                tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16((-pointer << 4) | bits);\n                pointer += 1 << (bits - 9);\n            }\n        }\n        for (var i = 0; i < lengths.length; i++) {\n            var bits = lengths[i];\n            if (bits == 0) {\n                continue;\n            }\n            code = nextCode[bits];\n            var revcode = Utils.bitReverse(code);\n            if (bits <= 9) {\n                do {\n                    tree[revcode] = Utils.bitConverterInt32ToInt16((i << 4) | bits);\n                    revcode += 1 << bits;\n                } while (revcode < 512);\n            }\n            else {\n                var subTree = tree[revcode & 511];\n                var treeLen = 1 << (subTree & 15);\n                subTree = -(subTree >> 4);\n                do {\n                    tree[subTree | (revcode >> 9)] = Utils.bitConverterInt32ToInt16((i << 4) | bits);\n                    revcode += 1 << bits;\n                } while (revcode < treeLen);\n            }\n            nextCode[bits] = code + (1 << (16 - bits));\n        }\n        return tree;\n    };\n    /// <summary>\n    /// Builds huffman tree from array of code lengths.\n    /// </summary>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    DecompressorHuffmanTree.prototype.buildTree = function (lengths) {\n        // Count of codes for each code length.\n        var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        // Numerical value of the smallest code for each code length.\n        var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        var prepareData = this.prepareData(blCount, nextCode, lengths);\n        this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);\n    };\n    /// <summary>\n    /// Reads and decompresses one symbol.\n    /// </summary>\n    /// <param name=\"input\"></param>\n    /// <returns></returns>\n    DecompressorHuffmanTree.prototype.unpackSymbol = function (input) {\n        var lookahead;\n        var symbol;\n        if ((lookahead = input.peekBits(9)) >= 0) {\n            if ((symbol = this.m_Tree[lookahead]) >= 0) {\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            var subtree = -(symbol >> 4);\n            var bitlen = symbol & 15;\n            if ((lookahead = input.peekBits(bitlen)) >= 0) {\n                symbol = this.m_Tree[subtree | (lookahead >> 9)];\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            else {\n                var bits = input.availableBits;\n                lookahead = input.peekBits(bits);\n                symbol = this.m_Tree[subtree | (lookahead >> 9)];\n                if ((symbol & 15) <= bits) {\n                    input.skipBits((symbol & 15));\n                    return symbol >> 4;\n                }\n                else {\n                    return -1;\n                }\n            }\n        }\n        else {\n            var bits = input.availableBits;\n            lookahead = input.peekBits(bits);\n            symbol = this.m_Tree[lookahead];\n            if (symbol >= 0 && (symbol & 15) <= bits) {\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            else {\n                return -1;\n            }\n        }\n    };\n    Object.defineProperty(DecompressorHuffmanTree, \"lengthTree\", {\n        /// <summary>\n        /// GET huffman tree for encoding and decoding lengths.\n        /// </summary>\n        get: function () {\n            return this.m_LengthTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DecompressorHuffmanTree, \"distanceTree\", {\n        /// <summary>\n        /// GET huffman tree for encoding and decoding distances.\n        /// </summary>\n        get: function () {\n            return this.m_DistanceTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// <summary>\n    /// Maximum count of bits.\n    /// </summary>\n    DecompressorHuffmanTree.MAX_BITLEN = 15;\n    return DecompressorHuffmanTree;\n}());\n\n/* eslint-enable */\n\n/* eslint-disable */\n/// <summary>\n/// Checksum calculator, based on Adler32 algorithm.\n/// </summary>\nvar ChecksumCalculator$1 = /** @__PURE__ @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /// <summary>\n    /// Updates checksum by calculating checksum of the\n    /// given buffer and adding it to current value.\n    /// </summary>\n    /// <param name=\"checksum\">Current checksum.</param>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    ChecksumCalculator.ChecksumUpdate = function (checksum, buffer, offset, length) {\n        var checkSumUInt = checksum;\n        var s1 = checkSumUInt & 65535;\n        var s2 = checkSumUInt >> this.DEF_CHECKSUM_BIT_OFFSET;\n        while (length > 0) {\n            var steps = Math.min(length, this.DEF_CHECKSUM_ITERATIONSCOUNT);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (buffer[offset++] & 255);\n                s2 = s2 + s1;\n            }\n            s1 %= this.DEF_CHECKSUM_BASE;\n            s2 %= this.DEF_CHECKSUM_BASE;\n        }\n        checkSumUInt = (s2 << this.DEF_CHECKSUM_BIT_OFFSET) | s1;\n        checksum = checkSumUInt;\n    };\n    /// <summary>\n    /// Generates checksum by calculating checksum of the\n    /// given buffer.\n    /// </summary>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    ChecksumCalculator.ChecksumGenerate = function (buffer, offset, length) {\n        var result = 1;\n        ChecksumCalculator.ChecksumUpdate(result, buffer, offset, length);\n        return result;\n    };\n    /// <summary>\n    /// Bits offset, used in adler checksum calculation.\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_BIT_OFFSET = 16;\n    /// <summary>\n    /// Lagrest prime, less than 65535\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_BASE = 65521;\n    /// <summary>\n    /// Count of iteration used in calculated of the adler checksumm.\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_ITERATIONSCOUNT = 3800;\n    return ChecksumCalculator;\n}());\n\n/* eslint-enable */\n\n/* eslint-disable */\nvar CompressedStreamReader = /** @__PURE__ @class */ (function () {\n    function CompressedStreamReader(stream, bNoWrap) {\n        /// <summary>\n        /// Code lengths for the code length alphabet.\n        /// </summary>\n        this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n        /// <summary>\n        /// Mask for compression method to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_METHOD_MASK = 15 << 8;\n        /// <summary>\n        /// Mask for compression info to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_INFO_MASK = 240 << 8;\n        /// <summary>\n        /// Mask for check bits to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FCHECK = 31;\n        /// <summary>\n        /// Mask for dictionary presence to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FDICT = 32;\n        /// <summary>\n        /// Mask for compression level to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FLEVEL = 192;\n        /// <summary>\n        /// Maximum size of the data window.\n        /// </summary>\n        this.DEF_MAX_WINDOW_SIZE = 65535;\n        /// <summary>\n        /// Maximum length of the repeatable block.\n        /// </summary>\n        this.DEF_HUFFMAN_REPEATE_MAX = 258;\n        /// <summary>\n        /// End of the block sign.\n        /// </summary>\n        this.DEF_HUFFMAN_END_BLOCK = 256;\n        /// <summary>\n        /// Minimal length code.\n        /// </summary>\n        this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257;\n        /// <summary>\n        /// Maximal length code.\n        /// </summary>\n        this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285;\n        /// <summary>\n        /// Maximal distance code.\n        /// </summary>\n        this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29;\n        /// <summary>\n        /// Currently calculated checksum,\n        /// based on Adler32 algorithm.\n        /// </summary>\n        this.mCheckSum = 1;\n        /// <summary>\n        /// Currently read 4 bytes.\n        /// </summary>\n        this.tBuffer = 0;\n        /// <summary>\n        /// Count of bits that are in buffer.\n        /// </summary>\n        this.mBufferedBits = 0;\n        /// <summary>\n        /// Temporary buffer.\n        /// </summary>\n        this.mTempBuffer = new Uint8Array(4);\n        /// <summary>\n        /// 32k buffer for unpacked data.\n        /// </summary>\n        this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE);\n        /// <summary>\n        /// No wrap mode.\n        /// </summary>\n        this.mbNoWrap = false;\n        /// <summary>\n        /// Window size, can not be larger than 32k.\n        /// </summary>\n        this.mWindowSize = 0;\n        /// <summary>\n        /// Current position in output stream.\n        /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n        /// </summary>\n        this.mCurrentPosition = 0;\n        /// <summary>\n        /// Data length.\n        /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n        /// </summary>\n        this.mDataLength = 0;\n        /// <summary>\n        /// Specifies wheather next block can to be read.\n        /// Reading can be denied because the header of the last block have been read.\n        /// </summary>\n        this.mbCanReadNextBlock = true;\n        /// <summary>\n        /// Specifies wheather user can read more data from stream.\n        /// </summary>\n        this.mbCanReadMoreData = true;\n        /// <summary>\n        /// Specifies wheather checksum has been read.\n        /// </summary>\n        this.mbCheckSumRead = false;\n        if (stream == null) {\n            throw new DOMException('stream');\n        }\n        if (stream.length === 0) {\n            throw new DOMException('stream - string can not be empty');\n        }\n        DecompressorHuffmanTree.init();\n        this.mInputStream = new Stream(stream);\n        this.mbNoWrap = bNoWrap;\n        if (!this.mbNoWrap) {\n            this.readZLibHeader();\n        }\n        this.decodeBlockHeader();\n    }\n    Object.defineProperty(CompressedStreamReader.prototype, \"mBuffer\", {\n        get: function () {\n            return this.tBuffer;\n        },\n        set: function (value) {\n            this.tBuffer = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    /// <summary>\n    /// Reads specified count of bits without adjusting position.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be read.</param>\n    /// <returns>Read value.</returns>\n    CompressedStreamReader.prototype.peekBits = function (count) {\n        if (count < 0) {\n            throw new DOMException('count', 'Bits count can not be less than zero.');\n        }\n        if (count > 32) {\n            throw new DOMException('count', 'Count of bits is too large.');\n        }\n        // If buffered data is not enough to give result,\n        // fill buffer.\n        if (this.mBufferedBits < count) {\n            this.fillBuffer();\n        }\n        // If you want to read 4 bytes and there is partial data in\n        // buffer, than you will fail.\n        if (this.mBufferedBits < count) {\n            return -1;\n        }\n        // Create bitmask for reading of count bits\n        var bitMask = ~(4294967295 << count);\n        var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask);\n        //Debug.WriteLine( /*new string( ' ', 32 - mBufferedBits + (int)( ( 32 - mBufferedBits ) / 8 ) ) + BitsToString( (int)mBuffer, mBufferedBits ) + \" \" + BitsToString( result, count ) +*/ \" \" + result.ToString() );\n        return result;\n    };\n    CompressedStreamReader.prototype.fillBuffer = function () {\n        var length = 4 - (this.mBufferedBits >> 3) -\n            (((this.mBufferedBits & 7) !== 0) ? 1 : 0);\n        if (length === 0) {\n            return;\n        }\n        //TODO: fix this\n        var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);\n        for (var i = 0; i < bytesRead; i++) {\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer |\n                (Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits)));\n            this.mBufferedBits += 8;\n        }\n        //TODO: fix this\n    };\n    /// <summary>\n    /// Skips specified count of bits.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be skipped.</param>\n    CompressedStreamReader.prototype.skipBits = function (count) {\n        if (count < 0) {\n            throw new DOMException('count', 'Bits count can not be less than zero.');\n        }\n        if (count === 0) {\n            return;\n        }\n        if (count >= this.mBufferedBits) {\n            count -= this.mBufferedBits;\n            this.mBufferedBits = 0;\n            this.mBuffer = 0;\n            // if something left, skip it.\n            if (count > 0) {\n                // Skip entire bytes.\n                this.mInputStream.position += (count >> 3); //TODO: fix this\n                count &= 7;\n                // Skip bits.\n                if (count > 0) {\n                    this.fillBuffer();\n                    this.mBufferedBits -= count;\n                    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n                }\n            }\n        }\n        else {\n            this.mBufferedBits -= count;\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        }\n    };\n    Object.defineProperty(CompressedStreamReader.prototype, \"availableBits\", {\n        get: function () {\n            return this.mBufferedBits;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// <summary>\n    /// Reads ZLib header with compression method and flags.\n    /// </summary>\n    CompressedStreamReader.prototype.readZLibHeader = function () {\n        // first 8 bits - compression Method and flags\n        // 8 other - flags\n        var header = this.readInt16();\n        //Debug.WriteLine( BitsToString( header ) );\n        if (header === -1) {\n            throw new DOMException('Header of the stream can not be read.');\n        }\n        if (header % 31 !== 0) {\n            throw new DOMException('Header checksum illegal');\n        }\n        if ((header & this.DEF_HEADER_METHOD_MASK) !== (8 << 8)) {\n            throw new DOMException('Unsupported compression method.');\n        }\n        this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);\n        if (this.mWindowSize > 65535) {\n            throw new DOMException('Unsupported window size for deflate compression method.');\n        }\n        if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {\n            // Get dictionary.\n            throw new DOMException('Custom dictionary is not supported at the moment.');\n        }\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt16 = function () {\n        var result = (this.readBits(8) << 8);\n        result |= this.readBits(8);\n        return result;\n    };\n    /// <summary>\n    /// Reads specified count of bits from stream.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be read.</param>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readBits = function (count) {\n        var result = this.peekBits(count);\n        if (result === -1) {\n            return -1;\n        }\n        this.mBufferedBits -= count;\n        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        return result;\n    };\n    /// <summary>\n    /// Reads and decodes block of data.\n    /// </summary>\n    /// <returns>True if buffer was empty and new data was read, otherwise - False.</returns>\n    CompressedStreamReader.prototype.decodeBlockHeader = function () {\n        if (!this.mbCanReadNextBlock) {\n            return false;\n        }\n        var bFinalBlock = this.readBits(1);\n        if (bFinalBlock === -1) {\n            return false;\n        }\n        var blockType = this.readBits(2);\n        if (blockType === -1) {\n            return false;\n        }\n        this.mbCanReadNextBlock = (bFinalBlock === 0);\n        //      ChecksumReset();\n        switch (blockType) {\n            case 0:\n                // Uncompressed data\n                this.mbReadingUncompressed = true;\n                this.skipToBoundary();\n                var length_1 = this.readInt16Inverted();\n                var lengthComplement = this.readInt16Inverted();\n                if (length_1 !== (lengthComplement ^ 0xffff)) {\n                    throw new DOMException('Wrong block length.');\n                }\n                if (length_1 > 65535) {\n                    throw new DOMException('Uncompressed block length can not be more than 65535.');\n                }\n                this.mUncompressedDataLength = length_1;\n                this.mCurrentLengthTree = null;\n                this.mCurrentDistanceTree = null;\n                break;\n            case 1:\n                // Compressed data with fixed huffman codes.\n                this.mbReadingUncompressed = false;\n                this.mUncompressedDataLength = -1;\n                this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;\n                this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;\n                break;\n            case 2:\n                // Compressed data with dynamic huffman codes.\n                this.mbReadingUncompressed = false;\n                this.mUncompressedDataLength = -1;\n                var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);\n                this.mCurrentLengthTree = trees.lengthTree;\n                this.mCurrentDistanceTree = trees.distanceTree;\n                break;\n            default:\n                throw new DOMException('Wrong block type.');\n        }\n        return true;\n    };\n    /// <summary>\n    /// Discards left-most partially used byte.\n    /// </summary>\n    CompressedStreamReader.prototype.skipToBoundary = function () {\n        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));\n        this.mBufferedBits &= ~7;\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt16Inverted = function () {\n        var result = (this.readBits(8));\n        result |= this.readBits(8) << 8;\n        return result;\n    };\n    /// <summary>\n    /// Reades dynamic huffman codes from block header.\n    /// </summary>\n    /// <param name=\"lengthTree\">Literals/Lengths tree.</param>\n    /// <param name=\"distanceTree\">Distances tree.</param>\n    CompressedStreamReader.prototype.decodeDynamicHeader = function (lengthTree, distanceTree) {\n        var bLastSymbol = 0;\n        var iLengthsCount = this.readBits(5);\n        var iDistancesCount = this.readBits(5);\n        var iCodeLengthsCount = this.readBits(4);\n        if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {\n            throw new DOMException('Wrong dynamic huffman codes.');\n        }\n        iLengthsCount += 257;\n        iDistancesCount += 1;\n        var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;\n        var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);\n        var arrDecoderCodeLengths = new Uint8Array(19);\n        iCodeLengthsCount += 4;\n        var iCurrentCode = 0;\n        while (iCurrentCode < iCodeLengthsCount) {\n            var len = this.readBits(3);\n            if (len < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;\n        }\n        var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);\n        iCurrentCode = 0;\n        for (;;) {\n            var symbol = void 0;\n            var bNeedBreak = false;\n            symbol = treeInternalDecoder.unpackSymbol(this);\n            while ((symbol & ~15) === 0) {\n                arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;\n                if (iCurrentCode === iResultingCodeLengthsCount) {\n                    bNeedBreak = true;\n                    break;\n                }\n                symbol = treeInternalDecoder.unpackSymbol(this);\n            }\n            if (bNeedBreak) {\n                break;\n            }\n            if (symbol < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            if (symbol >= 17) {\n                bLastSymbol = 0;\n            }\n            else if (iCurrentCode === 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            var miRepSymbol = symbol - 16;\n            var bits = CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];\n            var count = this.readBits(bits);\n            if (count < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            count += CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];\n            if (iCurrentCode + count > iResultingCodeLengthsCount) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            while (count-- > 0) {\n                arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;\n            }\n            if (iCurrentCode === iResultingCodeLengthsCount) {\n                break;\n            }\n        }\n        var tempArray = new Uint8Array(iLengthsCount);\n        tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0);\n        //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n        //Array.copy( arrResultingCodeLengths, 0, tempArray, 0, iLengthsCount );\n        lengthTree = new DecompressorHuffmanTree(tempArray);\n        tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount);\n        //Array.copy( arrResultingCodeLengths, iLengthsCount, tempArray, 0, iDistancesCount );\n        distanceTree = new DecompressorHuffmanTree(tempArray);\n        return { 'lengthTree': lengthTree, 'distanceTree': distanceTree };\n    };\n    /// <summary>\n    /// Decodes huffman codes.\n    /// </summary>\n    /// <returns>True if some data was read.</returns>\n    CompressedStreamReader.prototype.readHuffman = function () {\n        var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);\n        var dataRead = false;\n        //long maxdistance = DEF_MAX_WINDOW_SIZE >> 1;\n        var readdata = {};\n        // DEF_HUFFMAN_REPEATE_MAX - longest repeatable block, we should always reserve space for it because\n        // if we should not, we will have buffer overrun.\n        while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {\n            var symbol = void 0;\n            symbol = this.mCurrentLengthTree.unpackSymbol(this);\n            // Only codes 0..255 are valid independent symbols.\n            while (((symbol) & ~0xff) === 0) {\n                readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;\n                this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;\n                dataRead = true;\n                if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {\n                    return true;\n                }\n                //if( (mDataLength - mCurrentPosition ) < maxdistance ) return true;\n                symbol = this.mCurrentLengthTree.unpackSymbol(this);\n            }\n            if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {\n                if (symbol < this.DEF_HUFFMAN_END_BLOCK) {\n                    throw new DOMException('Illegal code.');\n                }\n                var numDataRead = dataRead ? 1 : 0;\n                this.mbCanReadMoreData = this.decodeBlockHeader();\n                var numReadMore = (this.mbCanReadMoreData) ? 1 : 0;\n                return (numDataRead | numReadMore) ? true : false;\n            }\n            if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {\n                throw new DOMException('Illegal repeat code length.');\n            }\n            var iRepeatLength = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol -\n                this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n            var iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol -\n                this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n            if (iRepeatExtraBits > 0) {\n                var extra = this.readBits(iRepeatExtraBits);\n                if (extra < 0) {\n                    throw new DOMException('Wrong data.');\n                }\n                iRepeatLength += extra;\n            }\n            // Unpack repeat distance.\n            symbol = this.mCurrentDistanceTree.unpackSymbol(this);\n            if (symbol < 0 || symbol > CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {\n                throw new DOMException('Wrong distance code.');\n            }\n            var iRepeatDistance = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];\n            iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];\n            if (iRepeatExtraBits > 0) {\n                var extra = this.readBits(iRepeatExtraBits);\n                if (extra < 0) {\n                    throw new DOMException('Wrong data.');\n                }\n                iRepeatDistance += extra;\n            }\n            // Copy data in slow repeat mode\n            for (var i = 0; i < iRepeatLength; i++) {\n                this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] =\n                    this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];\n                this.mDataLength++;\n                free--;\n            }\n            dataRead = true;\n        }\n        return dataRead;\n    };\n    /// <summary>\n    /// Reads data to buffer.\n    /// </summary>\n    /// <param name=\"buffer\">Output buffer for data.</param>\n    /// <param name=\"offset\">Offset in output data.</param>\n    /// <param name=\"length\">Length of the data to be read.</param>\n    /// <returns>Count of bytes actually read.</returns>\n    CompressedStreamReader.prototype.read = function (buffer, offset, length) {\n        if (buffer == null) {\n            throw new DOMException('buffer');\n        }\n        if (offset < 0 || offset > buffer.length - 1) {\n            throw new DOMException('offset', 'Offset does not belong to specified buffer.');\n        }\n        if (length < 0 || length > buffer.length - offset) {\n            throw new DOMException('length', 'Length is illegal.');\n        }\n        var initialLength = length;\n        while (length > 0) {\n            // Read from internal buffer.\n            if (this.mCurrentPosition < this.mDataLength) {\n                // Position in buffer array.\n                var inBlockPosition = (this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE);\n                // We can not read more than we have in buffer at once,\n                // and we not read more than till the array end.\n                var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, (this.mDataLength - this.mCurrentPosition));\n                // Reading not more, than the rest of the buffer.\n                dataToCopy = Math.min(dataToCopy, length);\n                //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n                // Copy data.\n                //Array.Copy( mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy );\n                //buffer.set(this.mBlockBuffer.slice(inBlockPosition, dataToCopy), offset);\n                Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy);\n                // Correct position, length,\n                this.mCurrentPosition += dataToCopy;\n                offset += dataToCopy;\n                length -= dataToCopy;\n            }\n            else {\n                if (!this.mbCanReadMoreData) {\n                    break;\n                }\n                var oldDataLength = this.mDataLength;\n                if (!this.mbReadingUncompressed) {\n                    if (!this.readHuffman()) {\n                        break;\n                    }\n                }\n                else {\n                    if (this.mUncompressedDataLength === 0) {\n                        // If there is no more data in stream, just exit.\n                        this.mbCanReadMoreData = this.decodeBlockHeader();\n                        if (!(this.mbCanReadMoreData)) {\n                            break;\n                        }\n                    }\n                    else {\n                        // Position of the data end in block buffer.\n                        var inBlockPosition = (this.mDataLength % this.DEF_MAX_WINDOW_SIZE);\n                        var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);\n                        var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);\n                        if (dataToRead !== dataRead) {\n                            throw new DOMException('Not enough data in stream.');\n                        }\n                        this.mUncompressedDataLength -= dataRead;\n                        this.mDataLength += dataRead;\n                    }\n                }\n                if (oldDataLength < this.mDataLength) {\n                    var start = (oldDataLength % this.DEF_MAX_WINDOW_SIZE);\n                    var end = (this.mDataLength % this.DEF_MAX_WINDOW_SIZE);\n                    if (start < end) {\n                        this.checksumUpdate(this.mBlockBuffer, start, end - start);\n                    }\n                    else {\n                        this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);\n                        if (end > 0) {\n                            this.checksumUpdate(this.mBlockBuffer, 0, end);\n                        }\n                    }\n                }\n            }\n        }\n        if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {\n            this.skipToBoundary();\n            var checkSum = this.readInt32();\n            //Debug.Assert( checkSum == mCheckSum, \"\" );\n            if (checkSum !== this.mCheckSum) {\n                throw new DOMException('Checksum check failed.');\n            }\n            this.mbCheckSumRead = true;\n        }\n        return initialLength - length;\n    };\n    /// <summary>\n    /// Reads array of bytes.\n    /// </summary>\n    /// <param name=\"buffer\">Output buffer.</param>\n    /// <param name=\"offset\">Offset in output buffer.</param>\n    /// <param name=\"length\">Length of the data to be read.</param>\n    /// <returns>Count of bytes actually read to the buffer.</returns>\n    CompressedStreamReader.prototype.readPackedBytes = function (buffer, offset, length) {\n        if (buffer == null) {\n            throw new DOMException('buffer');\n        }\n        if (offset < 0 || offset > buffer.length - 1) {\n            throw new DOMException('offset\", \"Offset can not be less than zero or greater than buffer length - 1.');\n        }\n        if (length < 0) {\n            throw new DOMException('length\", \"Length can not be less than zero.');\n        }\n        if (length > buffer.length - offset) {\n            throw new DOMException('length\", \"Length is too large.');\n        }\n        if ((this.mBufferedBits & 7) !== 0) {\n            throw new DOMException('Reading of unalligned data is not supported.');\n        }\n        if (length === 0) {\n            return 0;\n        }\n        var result = 0;\n        while (this.mBufferedBits > 0 && length > 0) {\n            buffer[offset++] = (this.mBuffer);\n            this.mBufferedBits -= 8;\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);\n            length--;\n            result++;\n        }\n        if (length > 0) {\n            //TODO: Fix this.\n            result += this.mInputStream.read(buffer, offset, length);\n        }\n        return result;\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt32 = function () {\n        var result = this.readBits(8) << 24;\n        result |= this.readBits(8) << 16;\n        result |= this.readBits(8) << 8;\n        result |= this.readBits(8);\n        return result;\n    };\n    /// <summary>\n    /// Updates checksum by calculating checksum of the\n    /// given buffer and adding it to current value.\n    /// </summary>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    CompressedStreamReader.prototype.checksumUpdate = function (buffer, offset, length) {\n        ChecksumCalculator$1.ChecksumUpdate(this.mCheckSum, buffer, offset, length);\n    };\n    CompressedStreamReader.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);\n    /// <summary>\n    /// Minimum count of repetions.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11];\n    /// <summary>\n    /// Bits, that responds for different repetion modes.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7];\n    /// <summary>\n    /// Length bases.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258\n    ];\n    /// <summary>\n    /// Length extended bits count.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0\n    ];\n    /// <summary>\n    /// Distance bases.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n    ];\n    /// <summary>\n    /// Distance extanded bits count.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13\n    ];\n    return CompressedStreamReader;\n}());\nvar Stream = /** @__PURE__ @class */ (function () {\n    function Stream(input) {\n        this.position = 0;\n        this.inputStream = new Uint8Array(input.buffer);\n    }\n    Object.defineProperty(Stream.prototype, \"length\", {\n        get: function () {\n            return this.inputStream.buffer.byteLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Stream.prototype.read = function (buffer, start, length) {\n        var temp = new Uint8Array(this.inputStream.buffer, this.position + start);\n        var data = temp.subarray(0, length);\n        buffer.set(data, 0);\n        this.position += data.byteLength;\n        return data.byteLength;\n    };\n    Stream.prototype.readByte = function () {\n        return this.inputStream[this.position++];\n    };\n    Stream.prototype.write = function (inputBuffer, offset, count) {\n        Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count);\n        // this.inputStream = new Uint8Array(this.inputStream.buffer, this.position + offset);\n        // this.inputStream.set(inputBuffer, offset);\n        this.position += count;\n    };\n    Stream.prototype.toByteArray = function () {\n        return new Uint8Array(this.inputStream.buffer);\n    };\n    return Stream;\n}());\n\n/* eslint-enable */\n\n/**\n * export ZipArchive class\n */\n\nexport { ZipArchive, ZipArchiveItemHelper, ZipArchiveItem, CompressedStreamWriter, CompressorHuffmanTree, ChecksumCalculator, Utils, DecompressorHuffmanTree, CompressedStreamReader, Stream };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}